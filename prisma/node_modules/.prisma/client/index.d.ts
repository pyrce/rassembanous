
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Roles
 * 
 */
export type Roles = {
  id: number
  role: string
}

/**
 * Model Users
 * 
 */
export type Users = {
  id: number
  nom: string
  prenom: string
  login: string
  password: string
  adresse: string
  email: string
  token: string
  id_role: number
}

/**
 * Model Lieu
 * 
 */
export type Lieu = {
  id: number
  nomLieu: string
  adresse: string
}

/**
 * Model Categories
 * 
 */
export type Categories = {
  id: number
  categorie: string
}

/**
 * Model evenements
 * 
 */
export type evenements = {
  id: number
  nom: string
  description: string
  id_lieu: number
  id_categorie: number
  dateDebut: Date
  dateFin: Date
  dateLimit: Date
  nbPlace: number
  prix: number
  isPublic: boolean
}

/**
 * Model event_partenaire
 * 
 */
export type event_partenaire = {
  id: number
  id_event: number
  id_partenaire: number
}

/**
 * Model partenaire_user
 * 
 */
export type partenaire_user = {
  id: number
  id_partenaire: number
  id_user: number
}

/**
 * Model mediatype
 * 
 */
export type mediatype = {
  id: number
  libelle: string
}

/**
 * Model media
 * 
 */
export type media = {
  id: number
  image: string
  id_event: number
  id_user: number
  id_type: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.roles.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.roles.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<GlobalReject>;

  /**
   * `prisma.lieu`: Exposes CRUD operations for the **Lieu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lieus
    * const lieus = await prisma.lieu.findMany()
    * ```
    */
  get lieu(): Prisma.LieuDelegate<GlobalReject>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **Categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.CategoriesDelegate<GlobalReject>;

  /**
   * `prisma.evenements`: Exposes CRUD operations for the **evenements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evenements
    * const evenements = await prisma.evenements.findMany()
    * ```
    */
  get evenements(): Prisma.evenementsDelegate<GlobalReject>;

  /**
   * `prisma.event_partenaire`: Exposes CRUD operations for the **event_partenaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_partenaires
    * const event_partenaires = await prisma.event_partenaire.findMany()
    * ```
    */
  get event_partenaire(): Prisma.event_partenaireDelegate<GlobalReject>;

  /**
   * `prisma.partenaire_user`: Exposes CRUD operations for the **partenaire_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partenaire_users
    * const partenaire_users = await prisma.partenaire_user.findMany()
    * ```
    */
  get partenaire_user(): Prisma.partenaire_userDelegate<GlobalReject>;

  /**
   * `prisma.mediatype`: Exposes CRUD operations for the **mediatype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mediatypes
    * const mediatypes = await prisma.mediatype.findMany()
    * ```
    */
  get mediatype(): Prisma.mediatypeDelegate<GlobalReject>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.mediaDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.11.0
   * Query Engine version: b371888aaf8f51357c7457d836b86d12da91658b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Roles: 'Roles',
    Users: 'Users',
    Lieu: 'Lieu',
    Categories: 'Categories',
    evenements: 'evenements',
    event_partenaire: 'event_partenaire',
    partenaire_user: 'partenaire_user',
    mediatype: 'mediatype',
    media: 'media'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RolesCountOutputType
   */


  export type RolesCountOutputType = {
    users: number
  }

  export type RolesCountOutputTypeSelect = {
    users?: boolean
  }

  export type RolesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RolesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RolesCountOutputType
    : S extends undefined
    ? never
    : S extends RolesCountOutputTypeArgs
    ?'include' extends U
    ? RolesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RolesCountOutputType ? RolesCountOutputType[P] : never
  } 
    : RolesCountOutputType
  : RolesCountOutputType




  // Custom InputTypes

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     * 
    **/
    select?: RolesCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    partenaire: number
    mypartenaire: number
    user: number
    media: number
  }

  export type UsersCountOutputTypeSelect = {
    partenaire?: boolean
    mypartenaire?: boolean
    user?: boolean
    media?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type LieuCountOutputType
   */


  export type LieuCountOutputType = {
    events: number
  }

  export type LieuCountOutputTypeSelect = {
    events?: boolean
  }

  export type LieuCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LieuCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LieuCountOutputType
    : S extends undefined
    ? never
    : S extends LieuCountOutputTypeArgs
    ?'include' extends U
    ? LieuCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LieuCountOutputType ? LieuCountOutputType[P] : never
  } 
    : LieuCountOutputType
  : LieuCountOutputType




  // Custom InputTypes

  /**
   * LieuCountOutputType without action
   */
  export type LieuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LieuCountOutputType
     * 
    **/
    select?: LieuCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoriesCountOutputType
   */


  export type CategoriesCountOutputType = {
    events: number
  }

  export type CategoriesCountOutputTypeSelect = {
    events?: boolean
  }

  export type CategoriesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoriesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoriesCountOutputType
    : S extends undefined
    ? never
    : S extends CategoriesCountOutputTypeArgs
    ?'include' extends U
    ? CategoriesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoriesCountOutputType ? CategoriesCountOutputType[P] : never
  } 
    : CategoriesCountOutputType
  : CategoriesCountOutputType




  // Custom InputTypes

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     * 
    **/
    select?: CategoriesCountOutputTypeSelect | null
  }



  /**
   * Count Type EvenementsCountOutputType
   */


  export type EvenementsCountOutputType = {
    event: number
    media: number
  }

  export type EvenementsCountOutputTypeSelect = {
    event?: boolean
    media?: boolean
  }

  export type EvenementsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EvenementsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EvenementsCountOutputType
    : S extends undefined
    ? never
    : S extends EvenementsCountOutputTypeArgs
    ?'include' extends U
    ? EvenementsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EvenementsCountOutputType ? EvenementsCountOutputType[P] : never
  } 
    : EvenementsCountOutputType
  : EvenementsCountOutputType




  // Custom InputTypes

  /**
   * EvenementsCountOutputType without action
   */
  export type EvenementsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EvenementsCountOutputType
     * 
    **/
    select?: EvenementsCountOutputTypeSelect | null
  }



  /**
   * Count Type MediatypeCountOutputType
   */


  export type MediatypeCountOutputType = {
    media: number
  }

  export type MediatypeCountOutputTypeSelect = {
    media?: boolean
  }

  export type MediatypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MediatypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MediatypeCountOutputType
    : S extends undefined
    ? never
    : S extends MediatypeCountOutputTypeArgs
    ?'include' extends U
    ? MediatypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MediatypeCountOutputType ? MediatypeCountOutputType[P] : never
  } 
    : MediatypeCountOutputType
  : MediatypeCountOutputType




  // Custom InputTypes

  /**
   * MediatypeCountOutputType without action
   */
  export type MediatypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MediatypeCountOutputType
     * 
    **/
    select?: MediatypeCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Roles
   */


  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    role: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    role: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    role: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    role?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    role?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    role?: true
    _all?: true
  }

  export type RolesAggregateArgs = {
    /**
     * Filter which Roles to aggregate.
     * 
    **/
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs = {
    where?: RolesWhereInput
    orderBy?: Enumerable<RolesOrderByWithAggregationInput>
    by: Array<RolesScalarFieldEnum>
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }


  export type RolesGroupByOutputType = {
    id: number
    role: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect = {
    id?: boolean
    role?: boolean
    users?: boolean | UsersFindManyArgs
    _count?: boolean | RolesCountOutputTypeArgs
  }

  export type RolesInclude = {
    users?: boolean | UsersFindManyArgs
    _count?: boolean | RolesCountOutputTypeArgs
  }

  export type RolesGetPayload<
    S extends boolean | null | undefined | RolesArgs,
    U = keyof S
      > = S extends true
        ? Roles
    : S extends undefined
    ? never
    : S extends RolesArgs | RolesFindManyArgs
    ?'include' extends U
    ? Roles  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? Array < UsersGetPayload<S['include'][P]>>  :
        P extends '_count' ? RolesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? Array < UsersGetPayload<S['select'][P]>>  :
        P extends '_count' ? RolesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Roles ? Roles[P] : never
  } 
    : Roles
  : Roles


  type RolesCountArgs = Merge<
    Omit<RolesFindManyArgs, 'select' | 'include'> & {
      select?: RolesCountAggregateInputType | true
    }
  >

  export interface RolesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Roles'> extends True ? CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>> : CheckSelect<T, Prisma__RolesClient<Roles | null >, Prisma__RolesClient<RolesGetPayload<T> | null >>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Roles'> extends True ? CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>> : CheckSelect<T, Prisma__RolesClient<Roles | null >, Prisma__RolesClient<RolesGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RolesFindManyArgs>(
      args?: SelectSubset<T, RolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Roles>>, PrismaPromise<Array<RolesGetPayload<T>>>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends RolesCreateArgs>(
      args: SelectSubset<T, RolesCreateArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolesCreateManyArgs>(
      args?: SelectSubset<T, RolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends RolesDeleteArgs>(
      args: SelectSubset<T, RolesDeleteArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolesUpdateArgs>(
      args: SelectSubset<T, RolesUpdateArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolesDeleteManyArgs>(
      args?: SelectSubset<T, RolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolesUpdateManyArgs>(
      args: SelectSubset<T, RolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends RolesUpsertArgs>(
      args: SelectSubset<T, RolesUpsertArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UsersFindManyArgs = {}>(args?: Subset<T, UsersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Users>>, PrismaPromise<Array<UsersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Throw an Error if a Roles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where: RolesWhereUniqueInput
  }


  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Throw an Error if a Roles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles findMany
   */
  export type RolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles create
   */
  export type RolesCreateArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * The data needed to create a Roles.
     * 
    **/
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }


  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs = {
    /**
     * The data used to create many Roles.
     * 
    **/
    data: Enumerable<RolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Roles update
   */
  export type RolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * The data needed to update a Roles.
     * 
    **/
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     * 
    **/
    where: RolesWhereUniqueInput
  }


  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs = {
    /**
     * The data used to update Roles.
     * 
    **/
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     * 
    **/
    where?: RolesWhereInput
  }


  /**
   * Roles upsert
   */
  export type RolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * The filter to search for the Roles to update in case it exists.
     * 
    **/
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     * 
    **/
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }


  /**
   * Roles delete
   */
  export type RolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Filter which Roles to delete.
     * 
    **/
    where: RolesWhereUniqueInput
  }


  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     * 
    **/
    where?: RolesWhereInput
  }


  /**
   * Roles without action
   */
  export type RolesArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
  }



  /**
   * Model Users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    id_role: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    id_role: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    login: string | null
    password: string | null
    adresse: string | null
    email: string | null
    token: string | null
    id_role: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    login: string | null
    password: string | null
    adresse: string | null
    email: string | null
    token: string | null
    id_role: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    login: number
    password: number
    adresse: number
    email: number
    token: number
    id_role: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    id_role?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    id_role?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    login?: true
    password?: true
    adresse?: true
    email?: true
    token?: true
    id_role?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    login?: true
    password?: true
    adresse?: true
    email?: true
    token?: true
    id_role?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    login?: true
    password?: true
    adresse?: true
    email?: true
    token?: true
    id_role?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which Users to aggregate.
     * 
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: UsersWhereInput
    orderBy?: Enumerable<UsersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    id_role: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    login?: boolean
    password?: boolean
    adresse?: boolean
    email?: boolean
    token?: boolean
    role?: boolean | RolesArgs
    id_role?: boolean
    partenaire?: boolean | event_partenaireFindManyArgs
    mypartenaire?: boolean | partenaire_userFindManyArgs
    user?: boolean | partenaire_userFindManyArgs
    media?: boolean | mediaFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type UsersInclude = {
    role?: boolean | RolesArgs
    partenaire?: boolean | event_partenaireFindManyArgs
    mypartenaire?: boolean | partenaire_userFindManyArgs
    user?: boolean | partenaire_userFindManyArgs
    media?: boolean | mediaFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type UsersGetPayload<
    S extends boolean | null | undefined | UsersArgs,
    U = keyof S
      > = S extends true
        ? Users
    : S extends undefined
    ? never
    : S extends UsersArgs | UsersFindManyArgs
    ?'include' extends U
    ? Users  & {
    [P in TrueKeys<S['include']>]:
        P extends 'role' ? RolesGetPayload<S['include'][P]> | null :
        P extends 'partenaire' ? Array < event_partenaireGetPayload<S['include'][P]>>  :
        P extends 'mypartenaire' ? Array < partenaire_userGetPayload<S['include'][P]>>  :
        P extends 'user' ? Array < partenaire_userGetPayload<S['include'][P]>>  :
        P extends 'media' ? Array < mediaGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'role' ? RolesGetPayload<S['select'][P]> | null :
        P extends 'partenaire' ? Array < event_partenaireGetPayload<S['select'][P]>>  :
        P extends 'mypartenaire' ? Array < partenaire_userGetPayload<S['select'][P]>>  :
        P extends 'user' ? Array < partenaire_userGetPayload<S['select'][P]>>  :
        P extends 'media' ? Array < mediaGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Users ? Users[P] : never
  } 
    : Users
  : Users


  type UsersCountArgs = Merge<
    Omit<UsersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface UsersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Users'> extends True ? CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>> : CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Users'> extends True ? CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>> : CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsersFindManyArgs>(
      args?: SelectSubset<T, UsersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Users>>, PrismaPromise<Array<UsersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends UsersCreateArgs>(
      args: SelectSubset<T, UsersCreateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UsersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersCreateManyArgs>(
      args?: SelectSubset<T, UsersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends UsersDeleteArgs>(
      args: SelectSubset<T, UsersDeleteArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersUpdateArgs>(
      args: SelectSubset<T, UsersUpdateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersDeleteManyArgs>(
      args?: SelectSubset<T, UsersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersUpdateManyArgs>(
      args: SelectSubset<T, UsersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends UsersUpsertArgs>(
      args: SelectSubset<T, UsersUpsertArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends RolesArgs = {}>(args?: Subset<T, RolesArgs>): CheckSelect<T, Prisma__RolesClient<Roles | null >, Prisma__RolesClient<RolesGetPayload<T> | null >>;

    partenaire<T extends event_partenaireFindManyArgs = {}>(args?: Subset<T, event_partenaireFindManyArgs>): CheckSelect<T, PrismaPromise<Array<event_partenaire>>, PrismaPromise<Array<event_partenaireGetPayload<T>>>>;

    mypartenaire<T extends partenaire_userFindManyArgs = {}>(args?: Subset<T, partenaire_userFindManyArgs>): CheckSelect<T, PrismaPromise<Array<partenaire_user>>, PrismaPromise<Array<partenaire_userGetPayload<T>>>>;

    user<T extends partenaire_userFindManyArgs = {}>(args?: Subset<T, partenaire_userFindManyArgs>): CheckSelect<T, PrismaPromise<Array<partenaire_user>>, PrismaPromise<Array<partenaire_userGetPayload<T>>>>;

    media<T extends mediaFindManyArgs = {}>(args?: Subset<T, mediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<media>>, PrismaPromise<Array<mediaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Throw an Error if a Users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Throw an Error if a Users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users findMany
   */
  export type UsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users create
   */
  export type UsersCreateArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * The data needed to create a Users.
     * 
    **/
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }


  /**
   * Users createMany
   */
  export type UsersCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UsersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Users update
   */
  export type UsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * The data needed to update a Users.
     * 
    **/
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     * 
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UsersWhereInput
  }


  /**
   * Users upsert
   */
  export type UsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * The filter to search for the Users to update in case it exists.
     * 
    **/
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     * 
    **/
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }


  /**
   * Users delete
   */
  export type UsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Filter which Users to delete.
     * 
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UsersWhereInput
  }


  /**
   * Users without action
   */
  export type UsersArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
  }



  /**
   * Model Lieu
   */


  export type AggregateLieu = {
    _count: LieuCountAggregateOutputType | null
    _avg: LieuAvgAggregateOutputType | null
    _sum: LieuSumAggregateOutputType | null
    _min: LieuMinAggregateOutputType | null
    _max: LieuMaxAggregateOutputType | null
  }

  export type LieuAvgAggregateOutputType = {
    id: number | null
  }

  export type LieuSumAggregateOutputType = {
    id: number | null
  }

  export type LieuMinAggregateOutputType = {
    id: number | null
    nomLieu: string | null
    adresse: string | null
  }

  export type LieuMaxAggregateOutputType = {
    id: number | null
    nomLieu: string | null
    adresse: string | null
  }

  export type LieuCountAggregateOutputType = {
    id: number
    nomLieu: number
    adresse: number
    _all: number
  }


  export type LieuAvgAggregateInputType = {
    id?: true
  }

  export type LieuSumAggregateInputType = {
    id?: true
  }

  export type LieuMinAggregateInputType = {
    id?: true
    nomLieu?: true
    adresse?: true
  }

  export type LieuMaxAggregateInputType = {
    id?: true
    nomLieu?: true
    adresse?: true
  }

  export type LieuCountAggregateInputType = {
    id?: true
    nomLieu?: true
    adresse?: true
    _all?: true
  }

  export type LieuAggregateArgs = {
    /**
     * Filter which Lieu to aggregate.
     * 
    **/
    where?: LieuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lieus to fetch.
     * 
    **/
    orderBy?: Enumerable<LieuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LieuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lieus from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lieus.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lieus
    **/
    _count?: true | LieuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LieuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LieuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LieuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LieuMaxAggregateInputType
  }

  export type GetLieuAggregateType<T extends LieuAggregateArgs> = {
        [P in keyof T & keyof AggregateLieu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLieu[P]>
      : GetScalarType<T[P], AggregateLieu[P]>
  }




  export type LieuGroupByArgs = {
    where?: LieuWhereInput
    orderBy?: Enumerable<LieuOrderByWithAggregationInput>
    by: Array<LieuScalarFieldEnum>
    having?: LieuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LieuCountAggregateInputType | true
    _avg?: LieuAvgAggregateInputType
    _sum?: LieuSumAggregateInputType
    _min?: LieuMinAggregateInputType
    _max?: LieuMaxAggregateInputType
  }


  export type LieuGroupByOutputType = {
    id: number
    nomLieu: string
    adresse: string
    _count: LieuCountAggregateOutputType | null
    _avg: LieuAvgAggregateOutputType | null
    _sum: LieuSumAggregateOutputType | null
    _min: LieuMinAggregateOutputType | null
    _max: LieuMaxAggregateOutputType | null
  }

  type GetLieuGroupByPayload<T extends LieuGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LieuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LieuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LieuGroupByOutputType[P]>
            : GetScalarType<T[P], LieuGroupByOutputType[P]>
        }
      >
    >


  export type LieuSelect = {
    id?: boolean
    nomLieu?: boolean
    adresse?: boolean
    events?: boolean | evenementsFindManyArgs
    _count?: boolean | LieuCountOutputTypeArgs
  }

  export type LieuInclude = {
    events?: boolean | evenementsFindManyArgs
    _count?: boolean | LieuCountOutputTypeArgs
  }

  export type LieuGetPayload<
    S extends boolean | null | undefined | LieuArgs,
    U = keyof S
      > = S extends true
        ? Lieu
    : S extends undefined
    ? never
    : S extends LieuArgs | LieuFindManyArgs
    ?'include' extends U
    ? Lieu  & {
    [P in TrueKeys<S['include']>]:
        P extends 'events' ? Array < evenementsGetPayload<S['include'][P]>>  :
        P extends '_count' ? LieuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'events' ? Array < evenementsGetPayload<S['select'][P]>>  :
        P extends '_count' ? LieuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Lieu ? Lieu[P] : never
  } 
    : Lieu
  : Lieu


  type LieuCountArgs = Merge<
    Omit<LieuFindManyArgs, 'select' | 'include'> & {
      select?: LieuCountAggregateInputType | true
    }
  >

  export interface LieuDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lieu that matches the filter.
     * @param {LieuFindUniqueArgs} args - Arguments to find a Lieu
     * @example
     * // Get one Lieu
     * const lieu = await prisma.lieu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LieuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LieuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Lieu'> extends True ? CheckSelect<T, Prisma__LieuClient<Lieu>, Prisma__LieuClient<LieuGetPayload<T>>> : CheckSelect<T, Prisma__LieuClient<Lieu | null >, Prisma__LieuClient<LieuGetPayload<T> | null >>

    /**
     * Find the first Lieu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuFindFirstArgs} args - Arguments to find a Lieu
     * @example
     * // Get one Lieu
     * const lieu = await prisma.lieu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LieuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LieuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Lieu'> extends True ? CheckSelect<T, Prisma__LieuClient<Lieu>, Prisma__LieuClient<LieuGetPayload<T>>> : CheckSelect<T, Prisma__LieuClient<Lieu | null >, Prisma__LieuClient<LieuGetPayload<T> | null >>

    /**
     * Find zero or more Lieus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lieus
     * const lieus = await prisma.lieu.findMany()
     * 
     * // Get first 10 Lieus
     * const lieus = await prisma.lieu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lieuWithIdOnly = await prisma.lieu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LieuFindManyArgs>(
      args?: SelectSubset<T, LieuFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Lieu>>, PrismaPromise<Array<LieuGetPayload<T>>>>

    /**
     * Create a Lieu.
     * @param {LieuCreateArgs} args - Arguments to create a Lieu.
     * @example
     * // Create one Lieu
     * const Lieu = await prisma.lieu.create({
     *   data: {
     *     // ... data to create a Lieu
     *   }
     * })
     * 
    **/
    create<T extends LieuCreateArgs>(
      args: SelectSubset<T, LieuCreateArgs>
    ): CheckSelect<T, Prisma__LieuClient<Lieu>, Prisma__LieuClient<LieuGetPayload<T>>>

    /**
     * Create many Lieus.
     *     @param {LieuCreateManyArgs} args - Arguments to create many Lieus.
     *     @example
     *     // Create many Lieus
     *     const lieu = await prisma.lieu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LieuCreateManyArgs>(
      args?: SelectSubset<T, LieuCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lieu.
     * @param {LieuDeleteArgs} args - Arguments to delete one Lieu.
     * @example
     * // Delete one Lieu
     * const Lieu = await prisma.lieu.delete({
     *   where: {
     *     // ... filter to delete one Lieu
     *   }
     * })
     * 
    **/
    delete<T extends LieuDeleteArgs>(
      args: SelectSubset<T, LieuDeleteArgs>
    ): CheckSelect<T, Prisma__LieuClient<Lieu>, Prisma__LieuClient<LieuGetPayload<T>>>

    /**
     * Update one Lieu.
     * @param {LieuUpdateArgs} args - Arguments to update one Lieu.
     * @example
     * // Update one Lieu
     * const lieu = await prisma.lieu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LieuUpdateArgs>(
      args: SelectSubset<T, LieuUpdateArgs>
    ): CheckSelect<T, Prisma__LieuClient<Lieu>, Prisma__LieuClient<LieuGetPayload<T>>>

    /**
     * Delete zero or more Lieus.
     * @param {LieuDeleteManyArgs} args - Arguments to filter Lieus to delete.
     * @example
     * // Delete a few Lieus
     * const { count } = await prisma.lieu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LieuDeleteManyArgs>(
      args?: SelectSubset<T, LieuDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lieus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lieus
     * const lieu = await prisma.lieu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LieuUpdateManyArgs>(
      args: SelectSubset<T, LieuUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lieu.
     * @param {LieuUpsertArgs} args - Arguments to update or create a Lieu.
     * @example
     * // Update or create a Lieu
     * const lieu = await prisma.lieu.upsert({
     *   create: {
     *     // ... data to create a Lieu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lieu we want to update
     *   }
     * })
    **/
    upsert<T extends LieuUpsertArgs>(
      args: SelectSubset<T, LieuUpsertArgs>
    ): CheckSelect<T, Prisma__LieuClient<Lieu>, Prisma__LieuClient<LieuGetPayload<T>>>

    /**
     * Count the number of Lieus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuCountArgs} args - Arguments to filter Lieus to count.
     * @example
     * // Count the number of Lieus
     * const count = await prisma.lieu.count({
     *   where: {
     *     // ... the filter for the Lieus we want to count
     *   }
     * })
    **/
    count<T extends LieuCountArgs>(
      args?: Subset<T, LieuCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LieuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lieu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LieuAggregateArgs>(args: Subset<T, LieuAggregateArgs>): PrismaPromise<GetLieuAggregateType<T>>

    /**
     * Group by Lieu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LieuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LieuGroupByArgs['orderBy'] }
        : { orderBy?: LieuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LieuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLieuGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lieu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LieuClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    events<T extends evenementsFindManyArgs = {}>(args?: Subset<T, evenementsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<evenements>>, PrismaPromise<Array<evenementsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Lieu findUnique
   */
  export type LieuFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
    /**
     * Throw an Error if a Lieu can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lieu to fetch.
     * 
    **/
    where: LieuWhereUniqueInput
  }


  /**
   * Lieu findFirst
   */
  export type LieuFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
    /**
     * Throw an Error if a Lieu can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lieu to fetch.
     * 
    **/
    where?: LieuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lieus to fetch.
     * 
    **/
    orderBy?: Enumerable<LieuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lieus.
     * 
    **/
    cursor?: LieuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lieus from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lieus.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lieus.
     * 
    **/
    distinct?: Enumerable<LieuScalarFieldEnum>
  }


  /**
   * Lieu findMany
   */
  export type LieuFindManyArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
    /**
     * Filter, which Lieus to fetch.
     * 
    **/
    where?: LieuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lieus to fetch.
     * 
    **/
    orderBy?: Enumerable<LieuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lieus.
     * 
    **/
    cursor?: LieuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lieus from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lieus.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LieuScalarFieldEnum>
  }


  /**
   * Lieu create
   */
  export type LieuCreateArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
    /**
     * The data needed to create a Lieu.
     * 
    **/
    data: XOR<LieuCreateInput, LieuUncheckedCreateInput>
  }


  /**
   * Lieu createMany
   */
  export type LieuCreateManyArgs = {
    /**
     * The data used to create many Lieus.
     * 
    **/
    data: Enumerable<LieuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Lieu update
   */
  export type LieuUpdateArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
    /**
     * The data needed to update a Lieu.
     * 
    **/
    data: XOR<LieuUpdateInput, LieuUncheckedUpdateInput>
    /**
     * Choose, which Lieu to update.
     * 
    **/
    where: LieuWhereUniqueInput
  }


  /**
   * Lieu updateMany
   */
  export type LieuUpdateManyArgs = {
    /**
     * The data used to update Lieus.
     * 
    **/
    data: XOR<LieuUpdateManyMutationInput, LieuUncheckedUpdateManyInput>
    /**
     * Filter which Lieus to update
     * 
    **/
    where?: LieuWhereInput
  }


  /**
   * Lieu upsert
   */
  export type LieuUpsertArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
    /**
     * The filter to search for the Lieu to update in case it exists.
     * 
    **/
    where: LieuWhereUniqueInput
    /**
     * In case the Lieu found by the `where` argument doesn't exist, create a new Lieu with this data.
     * 
    **/
    create: XOR<LieuCreateInput, LieuUncheckedCreateInput>
    /**
     * In case the Lieu was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LieuUpdateInput, LieuUncheckedUpdateInput>
  }


  /**
   * Lieu delete
   */
  export type LieuDeleteArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
    /**
     * Filter which Lieu to delete.
     * 
    **/
    where: LieuWhereUniqueInput
  }


  /**
   * Lieu deleteMany
   */
  export type LieuDeleteManyArgs = {
    /**
     * Filter which Lieus to delete
     * 
    **/
    where?: LieuWhereInput
  }


  /**
   * Lieu without action
   */
  export type LieuArgs = {
    /**
     * Select specific fields to fetch from the Lieu
     * 
    **/
    select?: LieuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LieuInclude | null
  }



  /**
   * Model Categories
   */


  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: number | null
    categorie: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: number | null
    categorie: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    categorie: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    categorie?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    categorie?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    categorie?: true
    _all?: true
  }

  export type CategoriesAggregateArgs = {
    /**
     * Filter which Categories to aggregate.
     * 
    **/
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs = {
    where?: CategoriesWhereInput
    orderBy?: Enumerable<CategoriesOrderByWithAggregationInput>
    by: Array<CategoriesScalarFieldEnum>
    having?: CategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }


  export type CategoriesGroupByOutputType = {
    id: number
    categorie: string
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesSelect = {
    id?: boolean
    categorie?: boolean
    events?: boolean | evenementsFindManyArgs
    _count?: boolean | CategoriesCountOutputTypeArgs
  }

  export type CategoriesInclude = {
    events?: boolean | evenementsFindManyArgs
    _count?: boolean | CategoriesCountOutputTypeArgs
  }

  export type CategoriesGetPayload<
    S extends boolean | null | undefined | CategoriesArgs,
    U = keyof S
      > = S extends true
        ? Categories
    : S extends undefined
    ? never
    : S extends CategoriesArgs | CategoriesFindManyArgs
    ?'include' extends U
    ? Categories  & {
    [P in TrueKeys<S['include']>]:
        P extends 'events' ? Array < evenementsGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoriesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'events' ? Array < evenementsGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoriesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Categories ? Categories[P] : never
  } 
    : Categories
  : Categories


  type CategoriesCountArgs = Merge<
    Omit<CategoriesFindManyArgs, 'select' | 'include'> & {
      select?: CategoriesCountAggregateInputType | true
    }
  >

  export interface CategoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Categories that matches the filter.
     * @param {CategoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Categories'> extends True ? CheckSelect<T, Prisma__CategoriesClient<Categories>, Prisma__CategoriesClient<CategoriesGetPayload<T>>> : CheckSelect<T, Prisma__CategoriesClient<Categories | null >, Prisma__CategoriesClient<CategoriesGetPayload<T> | null >>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Categories'> extends True ? CheckSelect<T, Prisma__CategoriesClient<Categories>, Prisma__CategoriesClient<CategoriesGetPayload<T>>> : CheckSelect<T, Prisma__CategoriesClient<Categories | null >, Prisma__CategoriesClient<CategoriesGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriesFindManyArgs>(
      args?: SelectSubset<T, CategoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Categories>>, PrismaPromise<Array<CategoriesGetPayload<T>>>>

    /**
     * Create a Categories.
     * @param {CategoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
    **/
    create<T extends CategoriesCreateArgs>(
      args: SelectSubset<T, CategoriesCreateArgs>
    ): CheckSelect<T, Prisma__CategoriesClient<Categories>, Prisma__CategoriesClient<CategoriesGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoriesCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const categories = await prisma.categories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriesCreateManyArgs>(
      args?: SelectSubset<T, CategoriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Categories.
     * @param {CategoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
    **/
    delete<T extends CategoriesDeleteArgs>(
      args: SelectSubset<T, CategoriesDeleteArgs>
    ): CheckSelect<T, Prisma__CategoriesClient<Categories>, Prisma__CategoriesClient<CategoriesGetPayload<T>>>

    /**
     * Update one Categories.
     * @param {CategoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriesUpdateArgs>(
      args: SelectSubset<T, CategoriesUpdateArgs>
    ): CheckSelect<T, Prisma__CategoriesClient<Categories>, Prisma__CategoriesClient<CategoriesGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriesDeleteManyArgs>(
      args?: SelectSubset<T, CategoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriesUpdateManyArgs>(
      args: SelectSubset<T, CategoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {CategoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriesUpsertArgs>(
      args: SelectSubset<T, CategoriesUpsertArgs>
    ): CheckSelect<T, Prisma__CategoriesClient<Categories>, Prisma__CategoriesClient<CategoriesGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoriesCountArgs>(
      args?: Subset<T, CategoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    events<T extends evenementsFindManyArgs = {}>(args?: Subset<T, evenementsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<evenements>>, PrismaPromise<Array<evenementsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Categories findUnique
   */
  export type CategoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
    /**
     * Throw an Error if a Categories can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where: CategoriesWhereUniqueInput
  }


  /**
   * Categories findFirst
   */
  export type CategoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
    /**
     * Throw an Error if a Categories can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoriesScalarFieldEnum>
  }


  /**
   * Categories findMany
   */
  export type CategoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     * 
    **/
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoriesScalarFieldEnum>
  }


  /**
   * Categories create
   */
  export type CategoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
    /**
     * The data needed to create a Categories.
     * 
    **/
    data: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
  }


  /**
   * Categories createMany
   */
  export type CategoriesCreateManyArgs = {
    /**
     * The data used to create many Categories.
     * 
    **/
    data: Enumerable<CategoriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Categories update
   */
  export type CategoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
    /**
     * The data needed to update a Categories.
     * 
    **/
    data: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
    /**
     * Choose, which Categories to update.
     * 
    **/
    where: CategoriesWhereUniqueInput
  }


  /**
   * Categories updateMany
   */
  export type CategoriesUpdateManyArgs = {
    /**
     * The data used to update Categories.
     * 
    **/
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     * 
    **/
    where?: CategoriesWhereInput
  }


  /**
   * Categories upsert
   */
  export type CategoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
    /**
     * The filter to search for the Categories to update in case it exists.
     * 
    **/
    where: CategoriesWhereUniqueInput
    /**
     * In case the Categories found by the `where` argument doesn't exist, create a new Categories with this data.
     * 
    **/
    create: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
    /**
     * In case the Categories was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
  }


  /**
   * Categories delete
   */
  export type CategoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
    /**
     * Filter which Categories to delete.
     * 
    **/
    where: CategoriesWhereUniqueInput
  }


  /**
   * Categories deleteMany
   */
  export type CategoriesDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     * 
    **/
    where?: CategoriesWhereInput
  }


  /**
   * Categories without action
   */
  export type CategoriesArgs = {
    /**
     * Select specific fields to fetch from the Categories
     * 
    **/
    select?: CategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriesInclude | null
  }



  /**
   * Model evenements
   */


  export type AggregateEvenements = {
    _count: EvenementsCountAggregateOutputType | null
    _avg: EvenementsAvgAggregateOutputType | null
    _sum: EvenementsSumAggregateOutputType | null
    _min: EvenementsMinAggregateOutputType | null
    _max: EvenementsMaxAggregateOutputType | null
  }

  export type EvenementsAvgAggregateOutputType = {
    id: number | null
    id_lieu: number | null
    id_categorie: number | null
    nbPlace: number | null
    prix: number | null
  }

  export type EvenementsSumAggregateOutputType = {
    id: number | null
    id_lieu: number | null
    id_categorie: number | null
    nbPlace: number | null
    prix: number | null
  }

  export type EvenementsMinAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    id_lieu: number | null
    id_categorie: number | null
    dateDebut: Date | null
    dateFin: Date | null
    dateLimit: Date | null
    nbPlace: number | null
    prix: number | null
    isPublic: boolean | null
  }

  export type EvenementsMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    id_lieu: number | null
    id_categorie: number | null
    dateDebut: Date | null
    dateFin: Date | null
    dateLimit: Date | null
    nbPlace: number | null
    prix: number | null
    isPublic: boolean | null
  }

  export type EvenementsCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    id_lieu: number
    id_categorie: number
    dateDebut: number
    dateFin: number
    dateLimit: number
    nbPlace: number
    prix: number
    isPublic: number
    _all: number
  }


  export type EvenementsAvgAggregateInputType = {
    id?: true
    id_lieu?: true
    id_categorie?: true
    nbPlace?: true
    prix?: true
  }

  export type EvenementsSumAggregateInputType = {
    id?: true
    id_lieu?: true
    id_categorie?: true
    nbPlace?: true
    prix?: true
  }

  export type EvenementsMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    id_lieu?: true
    id_categorie?: true
    dateDebut?: true
    dateFin?: true
    dateLimit?: true
    nbPlace?: true
    prix?: true
    isPublic?: true
  }

  export type EvenementsMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    id_lieu?: true
    id_categorie?: true
    dateDebut?: true
    dateFin?: true
    dateLimit?: true
    nbPlace?: true
    prix?: true
    isPublic?: true
  }

  export type EvenementsCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    id_lieu?: true
    id_categorie?: true
    dateDebut?: true
    dateFin?: true
    dateLimit?: true
    nbPlace?: true
    prix?: true
    isPublic?: true
    _all?: true
  }

  export type EvenementsAggregateArgs = {
    /**
     * Filter which evenements to aggregate.
     * 
    **/
    where?: evenementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evenements to fetch.
     * 
    **/
    orderBy?: Enumerable<evenementsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: evenementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evenements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evenements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned evenements
    **/
    _count?: true | EvenementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvenementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvenementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvenementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvenementsMaxAggregateInputType
  }

  export type GetEvenementsAggregateType<T extends EvenementsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvenements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvenements[P]>
      : GetScalarType<T[P], AggregateEvenements[P]>
  }




  export type EvenementsGroupByArgs = {
    where?: evenementsWhereInput
    orderBy?: Enumerable<evenementsOrderByWithAggregationInput>
    by: Array<EvenementsScalarFieldEnum>
    having?: evenementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvenementsCountAggregateInputType | true
    _avg?: EvenementsAvgAggregateInputType
    _sum?: EvenementsSumAggregateInputType
    _min?: EvenementsMinAggregateInputType
    _max?: EvenementsMaxAggregateInputType
  }


  export type EvenementsGroupByOutputType = {
    id: number
    nom: string
    description: string
    id_lieu: number
    id_categorie: number
    dateDebut: Date
    dateFin: Date
    dateLimit: Date
    nbPlace: number
    prix: number
    isPublic: boolean
    _count: EvenementsCountAggregateOutputType | null
    _avg: EvenementsAvgAggregateOutputType | null
    _sum: EvenementsSumAggregateOutputType | null
    _min: EvenementsMinAggregateOutputType | null
    _max: EvenementsMaxAggregateOutputType | null
  }

  type GetEvenementsGroupByPayload<T extends EvenementsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EvenementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvenementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvenementsGroupByOutputType[P]>
            : GetScalarType<T[P], EvenementsGroupByOutputType[P]>
        }
      >
    >


  export type evenementsSelect = {
    id?: boolean
    nom?: boolean
    description?: boolean
    id_lieu?: boolean
    id_categorie?: boolean
    lieu?: boolean | LieuArgs
    categorie?: boolean | CategoriesArgs
    dateDebut?: boolean
    dateFin?: boolean
    dateLimit?: boolean
    nbPlace?: boolean
    prix?: boolean
    isPublic?: boolean
    event?: boolean | event_partenaireFindManyArgs
    media?: boolean | mediaFindManyArgs
    _count?: boolean | EvenementsCountOutputTypeArgs
  }

  export type evenementsInclude = {
    lieu?: boolean | LieuArgs
    categorie?: boolean | CategoriesArgs
    event?: boolean | event_partenaireFindManyArgs
    media?: boolean | mediaFindManyArgs
    _count?: boolean | EvenementsCountOutputTypeArgs
  }

  export type evenementsGetPayload<
    S extends boolean | null | undefined | evenementsArgs,
    U = keyof S
      > = S extends true
        ? evenements
    : S extends undefined
    ? never
    : S extends evenementsArgs | evenementsFindManyArgs
    ?'include' extends U
    ? evenements  & {
    [P in TrueKeys<S['include']>]:
        P extends 'lieu' ? LieuGetPayload<S['include'][P]> | null :
        P extends 'categorie' ? CategoriesGetPayload<S['include'][P]> | null :
        P extends 'event' ? Array < event_partenaireGetPayload<S['include'][P]>>  :
        P extends 'media' ? Array < mediaGetPayload<S['include'][P]>>  :
        P extends '_count' ? EvenementsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'lieu' ? LieuGetPayload<S['select'][P]> | null :
        P extends 'categorie' ? CategoriesGetPayload<S['select'][P]> | null :
        P extends 'event' ? Array < event_partenaireGetPayload<S['select'][P]>>  :
        P extends 'media' ? Array < mediaGetPayload<S['select'][P]>>  :
        P extends '_count' ? EvenementsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof evenements ? evenements[P] : never
  } 
    : evenements
  : evenements


  type evenementsCountArgs = Merge<
    Omit<evenementsFindManyArgs, 'select' | 'include'> & {
      select?: EvenementsCountAggregateInputType | true
    }
  >

  export interface evenementsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Evenements that matches the filter.
     * @param {evenementsFindUniqueArgs} args - Arguments to find a Evenements
     * @example
     * // Get one Evenements
     * const evenements = await prisma.evenements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends evenementsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, evenementsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'evenements'> extends True ? CheckSelect<T, Prisma__evenementsClient<evenements>, Prisma__evenementsClient<evenementsGetPayload<T>>> : CheckSelect<T, Prisma__evenementsClient<evenements | null >, Prisma__evenementsClient<evenementsGetPayload<T> | null >>

    /**
     * Find the first Evenements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evenementsFindFirstArgs} args - Arguments to find a Evenements
     * @example
     * // Get one Evenements
     * const evenements = await prisma.evenements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends evenementsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, evenementsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'evenements'> extends True ? CheckSelect<T, Prisma__evenementsClient<evenements>, Prisma__evenementsClient<evenementsGetPayload<T>>> : CheckSelect<T, Prisma__evenementsClient<evenements | null >, Prisma__evenementsClient<evenementsGetPayload<T> | null >>

    /**
     * Find zero or more Evenements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evenementsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evenements
     * const evenements = await prisma.evenements.findMany()
     * 
     * // Get first 10 Evenements
     * const evenements = await prisma.evenements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evenementsWithIdOnly = await prisma.evenements.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends evenementsFindManyArgs>(
      args?: SelectSubset<T, evenementsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<evenements>>, PrismaPromise<Array<evenementsGetPayload<T>>>>

    /**
     * Create a Evenements.
     * @param {evenementsCreateArgs} args - Arguments to create a Evenements.
     * @example
     * // Create one Evenements
     * const Evenements = await prisma.evenements.create({
     *   data: {
     *     // ... data to create a Evenements
     *   }
     * })
     * 
    **/
    create<T extends evenementsCreateArgs>(
      args: SelectSubset<T, evenementsCreateArgs>
    ): CheckSelect<T, Prisma__evenementsClient<evenements>, Prisma__evenementsClient<evenementsGetPayload<T>>>

    /**
     * Create many Evenements.
     *     @param {evenementsCreateManyArgs} args - Arguments to create many Evenements.
     *     @example
     *     // Create many Evenements
     *     const evenements = await prisma.evenements.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends evenementsCreateManyArgs>(
      args?: SelectSubset<T, evenementsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Evenements.
     * @param {evenementsDeleteArgs} args - Arguments to delete one Evenements.
     * @example
     * // Delete one Evenements
     * const Evenements = await prisma.evenements.delete({
     *   where: {
     *     // ... filter to delete one Evenements
     *   }
     * })
     * 
    **/
    delete<T extends evenementsDeleteArgs>(
      args: SelectSubset<T, evenementsDeleteArgs>
    ): CheckSelect<T, Prisma__evenementsClient<evenements>, Prisma__evenementsClient<evenementsGetPayload<T>>>

    /**
     * Update one Evenements.
     * @param {evenementsUpdateArgs} args - Arguments to update one Evenements.
     * @example
     * // Update one Evenements
     * const evenements = await prisma.evenements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends evenementsUpdateArgs>(
      args: SelectSubset<T, evenementsUpdateArgs>
    ): CheckSelect<T, Prisma__evenementsClient<evenements>, Prisma__evenementsClient<evenementsGetPayload<T>>>

    /**
     * Delete zero or more Evenements.
     * @param {evenementsDeleteManyArgs} args - Arguments to filter Evenements to delete.
     * @example
     * // Delete a few Evenements
     * const { count } = await prisma.evenements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends evenementsDeleteManyArgs>(
      args?: SelectSubset<T, evenementsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evenementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evenements
     * const evenements = await prisma.evenements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends evenementsUpdateManyArgs>(
      args: SelectSubset<T, evenementsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Evenements.
     * @param {evenementsUpsertArgs} args - Arguments to update or create a Evenements.
     * @example
     * // Update or create a Evenements
     * const evenements = await prisma.evenements.upsert({
     *   create: {
     *     // ... data to create a Evenements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evenements we want to update
     *   }
     * })
    **/
    upsert<T extends evenementsUpsertArgs>(
      args: SelectSubset<T, evenementsUpsertArgs>
    ): CheckSelect<T, Prisma__evenementsClient<evenements>, Prisma__evenementsClient<evenementsGetPayload<T>>>

    /**
     * Count the number of Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evenementsCountArgs} args - Arguments to filter Evenements to count.
     * @example
     * // Count the number of Evenements
     * const count = await prisma.evenements.count({
     *   where: {
     *     // ... the filter for the Evenements we want to count
     *   }
     * })
    **/
    count<T extends evenementsCountArgs>(
      args?: Subset<T, evenementsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvenementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvenementsAggregateArgs>(args: Subset<T, EvenementsAggregateArgs>): PrismaPromise<GetEvenementsAggregateType<T>>

    /**
     * Group by Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvenementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvenementsGroupByArgs['orderBy'] }
        : { orderBy?: EvenementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvenementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvenementsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for evenements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__evenementsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    lieu<T extends LieuArgs = {}>(args?: Subset<T, LieuArgs>): CheckSelect<T, Prisma__LieuClient<Lieu | null >, Prisma__LieuClient<LieuGetPayload<T> | null >>;

    categorie<T extends CategoriesArgs = {}>(args?: Subset<T, CategoriesArgs>): CheckSelect<T, Prisma__CategoriesClient<Categories | null >, Prisma__CategoriesClient<CategoriesGetPayload<T> | null >>;

    event<T extends event_partenaireFindManyArgs = {}>(args?: Subset<T, event_partenaireFindManyArgs>): CheckSelect<T, PrismaPromise<Array<event_partenaire>>, PrismaPromise<Array<event_partenaireGetPayload<T>>>>;

    media<T extends mediaFindManyArgs = {}>(args?: Subset<T, mediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<media>>, PrismaPromise<Array<mediaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * evenements findUnique
   */
  export type evenementsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
    /**
     * Throw an Error if a evenements can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which evenements to fetch.
     * 
    **/
    where: evenementsWhereUniqueInput
  }


  /**
   * evenements findFirst
   */
  export type evenementsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
    /**
     * Throw an Error if a evenements can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which evenements to fetch.
     * 
    **/
    where?: evenementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evenements to fetch.
     * 
    **/
    orderBy?: Enumerable<evenementsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evenements.
     * 
    **/
    cursor?: evenementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evenements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evenements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evenements.
     * 
    **/
    distinct?: Enumerable<EvenementsScalarFieldEnum>
  }


  /**
   * evenements findMany
   */
  export type evenementsFindManyArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
    /**
     * Filter, which evenements to fetch.
     * 
    **/
    where?: evenementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evenements to fetch.
     * 
    **/
    orderBy?: Enumerable<evenementsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing evenements.
     * 
    **/
    cursor?: evenementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evenements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evenements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EvenementsScalarFieldEnum>
  }


  /**
   * evenements create
   */
  export type evenementsCreateArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
    /**
     * The data needed to create a evenements.
     * 
    **/
    data: XOR<evenementsCreateInput, evenementsUncheckedCreateInput>
  }


  /**
   * evenements createMany
   */
  export type evenementsCreateManyArgs = {
    /**
     * The data used to create many evenements.
     * 
    **/
    data: Enumerable<evenementsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * evenements update
   */
  export type evenementsUpdateArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
    /**
     * The data needed to update a evenements.
     * 
    **/
    data: XOR<evenementsUpdateInput, evenementsUncheckedUpdateInput>
    /**
     * Choose, which evenements to update.
     * 
    **/
    where: evenementsWhereUniqueInput
  }


  /**
   * evenements updateMany
   */
  export type evenementsUpdateManyArgs = {
    /**
     * The data used to update evenements.
     * 
    **/
    data: XOR<evenementsUpdateManyMutationInput, evenementsUncheckedUpdateManyInput>
    /**
     * Filter which evenements to update
     * 
    **/
    where?: evenementsWhereInput
  }


  /**
   * evenements upsert
   */
  export type evenementsUpsertArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
    /**
     * The filter to search for the evenements to update in case it exists.
     * 
    **/
    where: evenementsWhereUniqueInput
    /**
     * In case the evenements found by the `where` argument doesn't exist, create a new evenements with this data.
     * 
    **/
    create: XOR<evenementsCreateInput, evenementsUncheckedCreateInput>
    /**
     * In case the evenements was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<evenementsUpdateInput, evenementsUncheckedUpdateInput>
  }


  /**
   * evenements delete
   */
  export type evenementsDeleteArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
    /**
     * Filter which evenements to delete.
     * 
    **/
    where: evenementsWhereUniqueInput
  }


  /**
   * evenements deleteMany
   */
  export type evenementsDeleteManyArgs = {
    /**
     * Filter which evenements to delete
     * 
    **/
    where?: evenementsWhereInput
  }


  /**
   * evenements without action
   */
  export type evenementsArgs = {
    /**
     * Select specific fields to fetch from the evenements
     * 
    **/
    select?: evenementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: evenementsInclude | null
  }



  /**
   * Model event_partenaire
   */


  export type AggregateEvent_partenaire = {
    _count: Event_partenaireCountAggregateOutputType | null
    _avg: Event_partenaireAvgAggregateOutputType | null
    _sum: Event_partenaireSumAggregateOutputType | null
    _min: Event_partenaireMinAggregateOutputType | null
    _max: Event_partenaireMaxAggregateOutputType | null
  }

  export type Event_partenaireAvgAggregateOutputType = {
    id: number | null
    id_event: number | null
    id_partenaire: number | null
  }

  export type Event_partenaireSumAggregateOutputType = {
    id: number | null
    id_event: number | null
    id_partenaire: number | null
  }

  export type Event_partenaireMinAggregateOutputType = {
    id: number | null
    id_event: number | null
    id_partenaire: number | null
  }

  export type Event_partenaireMaxAggregateOutputType = {
    id: number | null
    id_event: number | null
    id_partenaire: number | null
  }

  export type Event_partenaireCountAggregateOutputType = {
    id: number
    id_event: number
    id_partenaire: number
    _all: number
  }


  export type Event_partenaireAvgAggregateInputType = {
    id?: true
    id_event?: true
    id_partenaire?: true
  }

  export type Event_partenaireSumAggregateInputType = {
    id?: true
    id_event?: true
    id_partenaire?: true
  }

  export type Event_partenaireMinAggregateInputType = {
    id?: true
    id_event?: true
    id_partenaire?: true
  }

  export type Event_partenaireMaxAggregateInputType = {
    id?: true
    id_event?: true
    id_partenaire?: true
  }

  export type Event_partenaireCountAggregateInputType = {
    id?: true
    id_event?: true
    id_partenaire?: true
    _all?: true
  }

  export type Event_partenaireAggregateArgs = {
    /**
     * Filter which event_partenaire to aggregate.
     * 
    **/
    where?: event_partenaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_partenaires to fetch.
     * 
    **/
    orderBy?: Enumerable<event_partenaireOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: event_partenaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_partenaires from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_partenaires.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_partenaires
    **/
    _count?: true | Event_partenaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_partenaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_partenaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_partenaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_partenaireMaxAggregateInputType
  }

  export type GetEvent_partenaireAggregateType<T extends Event_partenaireAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_partenaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_partenaire[P]>
      : GetScalarType<T[P], AggregateEvent_partenaire[P]>
  }




  export type Event_partenaireGroupByArgs = {
    where?: event_partenaireWhereInput
    orderBy?: Enumerable<event_partenaireOrderByWithAggregationInput>
    by: Array<Event_partenaireScalarFieldEnum>
    having?: event_partenaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_partenaireCountAggregateInputType | true
    _avg?: Event_partenaireAvgAggregateInputType
    _sum?: Event_partenaireSumAggregateInputType
    _min?: Event_partenaireMinAggregateInputType
    _max?: Event_partenaireMaxAggregateInputType
  }


  export type Event_partenaireGroupByOutputType = {
    id: number
    id_event: number
    id_partenaire: number
    _count: Event_partenaireCountAggregateOutputType | null
    _avg: Event_partenaireAvgAggregateOutputType | null
    _sum: Event_partenaireSumAggregateOutputType | null
    _min: Event_partenaireMinAggregateOutputType | null
    _max: Event_partenaireMaxAggregateOutputType | null
  }

  type GetEvent_partenaireGroupByPayload<T extends Event_partenaireGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Event_partenaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_partenaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_partenaireGroupByOutputType[P]>
            : GetScalarType<T[P], Event_partenaireGroupByOutputType[P]>
        }
      >
    >


  export type event_partenaireSelect = {
    id?: boolean
    id_event?: boolean
    id_partenaire?: boolean
    event?: boolean | evenementsArgs
    partenaire?: boolean | UsersArgs
  }

  export type event_partenaireInclude = {
    event?: boolean | evenementsArgs
    partenaire?: boolean | UsersArgs
  }

  export type event_partenaireGetPayload<
    S extends boolean | null | undefined | event_partenaireArgs,
    U = keyof S
      > = S extends true
        ? event_partenaire
    : S extends undefined
    ? never
    : S extends event_partenaireArgs | event_partenaireFindManyArgs
    ?'include' extends U
    ? event_partenaire  & {
    [P in TrueKeys<S['include']>]:
        P extends 'event' ? evenementsGetPayload<S['include'][P]> | null :
        P extends 'partenaire' ? UsersGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'event' ? evenementsGetPayload<S['select'][P]> | null :
        P extends 'partenaire' ? UsersGetPayload<S['select'][P]> | null :  P extends keyof event_partenaire ? event_partenaire[P] : never
  } 
    : event_partenaire
  : event_partenaire


  type event_partenaireCountArgs = Merge<
    Omit<event_partenaireFindManyArgs, 'select' | 'include'> & {
      select?: Event_partenaireCountAggregateInputType | true
    }
  >

  export interface event_partenaireDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Event_partenaire that matches the filter.
     * @param {event_partenaireFindUniqueArgs} args - Arguments to find a Event_partenaire
     * @example
     * // Get one Event_partenaire
     * const event_partenaire = await prisma.event_partenaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_partenaireFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, event_partenaireFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'event_partenaire'> extends True ? CheckSelect<T, Prisma__event_partenaireClient<event_partenaire>, Prisma__event_partenaireClient<event_partenaireGetPayload<T>>> : CheckSelect<T, Prisma__event_partenaireClient<event_partenaire | null >, Prisma__event_partenaireClient<event_partenaireGetPayload<T> | null >>

    /**
     * Find the first Event_partenaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_partenaireFindFirstArgs} args - Arguments to find a Event_partenaire
     * @example
     * // Get one Event_partenaire
     * const event_partenaire = await prisma.event_partenaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_partenaireFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, event_partenaireFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'event_partenaire'> extends True ? CheckSelect<T, Prisma__event_partenaireClient<event_partenaire>, Prisma__event_partenaireClient<event_partenaireGetPayload<T>>> : CheckSelect<T, Prisma__event_partenaireClient<event_partenaire | null >, Prisma__event_partenaireClient<event_partenaireGetPayload<T> | null >>

    /**
     * Find zero or more Event_partenaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_partenaireFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_partenaires
     * const event_partenaires = await prisma.event_partenaire.findMany()
     * 
     * // Get first 10 Event_partenaires
     * const event_partenaires = await prisma.event_partenaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const event_partenaireWithIdOnly = await prisma.event_partenaire.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends event_partenaireFindManyArgs>(
      args?: SelectSubset<T, event_partenaireFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<event_partenaire>>, PrismaPromise<Array<event_partenaireGetPayload<T>>>>

    /**
     * Create a Event_partenaire.
     * @param {event_partenaireCreateArgs} args - Arguments to create a Event_partenaire.
     * @example
     * // Create one Event_partenaire
     * const Event_partenaire = await prisma.event_partenaire.create({
     *   data: {
     *     // ... data to create a Event_partenaire
     *   }
     * })
     * 
    **/
    create<T extends event_partenaireCreateArgs>(
      args: SelectSubset<T, event_partenaireCreateArgs>
    ): CheckSelect<T, Prisma__event_partenaireClient<event_partenaire>, Prisma__event_partenaireClient<event_partenaireGetPayload<T>>>

    /**
     * Create many Event_partenaires.
     *     @param {event_partenaireCreateManyArgs} args - Arguments to create many Event_partenaires.
     *     @example
     *     // Create many Event_partenaires
     *     const event_partenaire = await prisma.event_partenaire.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_partenaireCreateManyArgs>(
      args?: SelectSubset<T, event_partenaireCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Event_partenaire.
     * @param {event_partenaireDeleteArgs} args - Arguments to delete one Event_partenaire.
     * @example
     * // Delete one Event_partenaire
     * const Event_partenaire = await prisma.event_partenaire.delete({
     *   where: {
     *     // ... filter to delete one Event_partenaire
     *   }
     * })
     * 
    **/
    delete<T extends event_partenaireDeleteArgs>(
      args: SelectSubset<T, event_partenaireDeleteArgs>
    ): CheckSelect<T, Prisma__event_partenaireClient<event_partenaire>, Prisma__event_partenaireClient<event_partenaireGetPayload<T>>>

    /**
     * Update one Event_partenaire.
     * @param {event_partenaireUpdateArgs} args - Arguments to update one Event_partenaire.
     * @example
     * // Update one Event_partenaire
     * const event_partenaire = await prisma.event_partenaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_partenaireUpdateArgs>(
      args: SelectSubset<T, event_partenaireUpdateArgs>
    ): CheckSelect<T, Prisma__event_partenaireClient<event_partenaire>, Prisma__event_partenaireClient<event_partenaireGetPayload<T>>>

    /**
     * Delete zero or more Event_partenaires.
     * @param {event_partenaireDeleteManyArgs} args - Arguments to filter Event_partenaires to delete.
     * @example
     * // Delete a few Event_partenaires
     * const { count } = await prisma.event_partenaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_partenaireDeleteManyArgs>(
      args?: SelectSubset<T, event_partenaireDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_partenaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_partenaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_partenaires
     * const event_partenaire = await prisma.event_partenaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_partenaireUpdateManyArgs>(
      args: SelectSubset<T, event_partenaireUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_partenaire.
     * @param {event_partenaireUpsertArgs} args - Arguments to update or create a Event_partenaire.
     * @example
     * // Update or create a Event_partenaire
     * const event_partenaire = await prisma.event_partenaire.upsert({
     *   create: {
     *     // ... data to create a Event_partenaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_partenaire we want to update
     *   }
     * })
    **/
    upsert<T extends event_partenaireUpsertArgs>(
      args: SelectSubset<T, event_partenaireUpsertArgs>
    ): CheckSelect<T, Prisma__event_partenaireClient<event_partenaire>, Prisma__event_partenaireClient<event_partenaireGetPayload<T>>>

    /**
     * Count the number of Event_partenaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_partenaireCountArgs} args - Arguments to filter Event_partenaires to count.
     * @example
     * // Count the number of Event_partenaires
     * const count = await prisma.event_partenaire.count({
     *   where: {
     *     // ... the filter for the Event_partenaires we want to count
     *   }
     * })
    **/
    count<T extends event_partenaireCountArgs>(
      args?: Subset<T, event_partenaireCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_partenaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_partenaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_partenaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_partenaireAggregateArgs>(args: Subset<T, Event_partenaireAggregateArgs>): PrismaPromise<GetEvent_partenaireAggregateType<T>>

    /**
     * Group by Event_partenaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_partenaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Event_partenaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Event_partenaireGroupByArgs['orderBy'] }
        : { orderBy?: Event_partenaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Event_partenaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_partenaireGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_partenaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_partenaireClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    event<T extends evenementsArgs = {}>(args?: Subset<T, evenementsArgs>): CheckSelect<T, Prisma__evenementsClient<evenements | null >, Prisma__evenementsClient<evenementsGetPayload<T> | null >>;

    partenaire<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * event_partenaire findUnique
   */
  export type event_partenaireFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
    /**
     * Throw an Error if a event_partenaire can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which event_partenaire to fetch.
     * 
    **/
    where: event_partenaireWhereUniqueInput
  }


  /**
   * event_partenaire findFirst
   */
  export type event_partenaireFindFirstArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
    /**
     * Throw an Error if a event_partenaire can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which event_partenaire to fetch.
     * 
    **/
    where?: event_partenaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_partenaires to fetch.
     * 
    **/
    orderBy?: Enumerable<event_partenaireOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_partenaires.
     * 
    **/
    cursor?: event_partenaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_partenaires from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_partenaires.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_partenaires.
     * 
    **/
    distinct?: Enumerable<Event_partenaireScalarFieldEnum>
  }


  /**
   * event_partenaire findMany
   */
  export type event_partenaireFindManyArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
    /**
     * Filter, which event_partenaires to fetch.
     * 
    **/
    where?: event_partenaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_partenaires to fetch.
     * 
    **/
    orderBy?: Enumerable<event_partenaireOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_partenaires.
     * 
    **/
    cursor?: event_partenaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_partenaires from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_partenaires.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Event_partenaireScalarFieldEnum>
  }


  /**
   * event_partenaire create
   */
  export type event_partenaireCreateArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
    /**
     * The data needed to create a event_partenaire.
     * 
    **/
    data: XOR<event_partenaireCreateInput, event_partenaireUncheckedCreateInput>
  }


  /**
   * event_partenaire createMany
   */
  export type event_partenaireCreateManyArgs = {
    /**
     * The data used to create many event_partenaires.
     * 
    **/
    data: Enumerable<event_partenaireCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * event_partenaire update
   */
  export type event_partenaireUpdateArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
    /**
     * The data needed to update a event_partenaire.
     * 
    **/
    data: XOR<event_partenaireUpdateInput, event_partenaireUncheckedUpdateInput>
    /**
     * Choose, which event_partenaire to update.
     * 
    **/
    where: event_partenaireWhereUniqueInput
  }


  /**
   * event_partenaire updateMany
   */
  export type event_partenaireUpdateManyArgs = {
    /**
     * The data used to update event_partenaires.
     * 
    **/
    data: XOR<event_partenaireUpdateManyMutationInput, event_partenaireUncheckedUpdateManyInput>
    /**
     * Filter which event_partenaires to update
     * 
    **/
    where?: event_partenaireWhereInput
  }


  /**
   * event_partenaire upsert
   */
  export type event_partenaireUpsertArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
    /**
     * The filter to search for the event_partenaire to update in case it exists.
     * 
    **/
    where: event_partenaireWhereUniqueInput
    /**
     * In case the event_partenaire found by the `where` argument doesn't exist, create a new event_partenaire with this data.
     * 
    **/
    create: XOR<event_partenaireCreateInput, event_partenaireUncheckedCreateInput>
    /**
     * In case the event_partenaire was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<event_partenaireUpdateInput, event_partenaireUncheckedUpdateInput>
  }


  /**
   * event_partenaire delete
   */
  export type event_partenaireDeleteArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
    /**
     * Filter which event_partenaire to delete.
     * 
    **/
    where: event_partenaireWhereUniqueInput
  }


  /**
   * event_partenaire deleteMany
   */
  export type event_partenaireDeleteManyArgs = {
    /**
     * Filter which event_partenaires to delete
     * 
    **/
    where?: event_partenaireWhereInput
  }


  /**
   * event_partenaire without action
   */
  export type event_partenaireArgs = {
    /**
     * Select specific fields to fetch from the event_partenaire
     * 
    **/
    select?: event_partenaireSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: event_partenaireInclude | null
  }



  /**
   * Model partenaire_user
   */


  export type AggregatePartenaire_user = {
    _count: Partenaire_userCountAggregateOutputType | null
    _avg: Partenaire_userAvgAggregateOutputType | null
    _sum: Partenaire_userSumAggregateOutputType | null
    _min: Partenaire_userMinAggregateOutputType | null
    _max: Partenaire_userMaxAggregateOutputType | null
  }

  export type Partenaire_userAvgAggregateOutputType = {
    id: number | null
    id_partenaire: number | null
    id_user: number | null
  }

  export type Partenaire_userSumAggregateOutputType = {
    id: number | null
    id_partenaire: number | null
    id_user: number | null
  }

  export type Partenaire_userMinAggregateOutputType = {
    id: number | null
    id_partenaire: number | null
    id_user: number | null
  }

  export type Partenaire_userMaxAggregateOutputType = {
    id: number | null
    id_partenaire: number | null
    id_user: number | null
  }

  export type Partenaire_userCountAggregateOutputType = {
    id: number
    id_partenaire: number
    id_user: number
    _all: number
  }


  export type Partenaire_userAvgAggregateInputType = {
    id?: true
    id_partenaire?: true
    id_user?: true
  }

  export type Partenaire_userSumAggregateInputType = {
    id?: true
    id_partenaire?: true
    id_user?: true
  }

  export type Partenaire_userMinAggregateInputType = {
    id?: true
    id_partenaire?: true
    id_user?: true
  }

  export type Partenaire_userMaxAggregateInputType = {
    id?: true
    id_partenaire?: true
    id_user?: true
  }

  export type Partenaire_userCountAggregateInputType = {
    id?: true
    id_partenaire?: true
    id_user?: true
    _all?: true
  }

  export type Partenaire_userAggregateArgs = {
    /**
     * Filter which partenaire_user to aggregate.
     * 
    **/
    where?: partenaire_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partenaire_users to fetch.
     * 
    **/
    orderBy?: Enumerable<partenaire_userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: partenaire_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partenaire_users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partenaire_users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned partenaire_users
    **/
    _count?: true | Partenaire_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Partenaire_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Partenaire_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Partenaire_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Partenaire_userMaxAggregateInputType
  }

  export type GetPartenaire_userAggregateType<T extends Partenaire_userAggregateArgs> = {
        [P in keyof T & keyof AggregatePartenaire_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartenaire_user[P]>
      : GetScalarType<T[P], AggregatePartenaire_user[P]>
  }




  export type Partenaire_userGroupByArgs = {
    where?: partenaire_userWhereInput
    orderBy?: Enumerable<partenaire_userOrderByWithAggregationInput>
    by: Array<Partenaire_userScalarFieldEnum>
    having?: partenaire_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Partenaire_userCountAggregateInputType | true
    _avg?: Partenaire_userAvgAggregateInputType
    _sum?: Partenaire_userSumAggregateInputType
    _min?: Partenaire_userMinAggregateInputType
    _max?: Partenaire_userMaxAggregateInputType
  }


  export type Partenaire_userGroupByOutputType = {
    id: number
    id_partenaire: number
    id_user: number
    _count: Partenaire_userCountAggregateOutputType | null
    _avg: Partenaire_userAvgAggregateOutputType | null
    _sum: Partenaire_userSumAggregateOutputType | null
    _min: Partenaire_userMinAggregateOutputType | null
    _max: Partenaire_userMaxAggregateOutputType | null
  }

  type GetPartenaire_userGroupByPayload<T extends Partenaire_userGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Partenaire_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Partenaire_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Partenaire_userGroupByOutputType[P]>
            : GetScalarType<T[P], Partenaire_userGroupByOutputType[P]>
        }
      >
    >


  export type partenaire_userSelect = {
    id?: boolean
    id_partenaire?: boolean
    mypartenaire?: boolean | UsersArgs
    id_user?: boolean
    user?: boolean | UsersArgs
  }

  export type partenaire_userInclude = {
    mypartenaire?: boolean | UsersArgs
    user?: boolean | UsersArgs
  }

  export type partenaire_userGetPayload<
    S extends boolean | null | undefined | partenaire_userArgs,
    U = keyof S
      > = S extends true
        ? partenaire_user
    : S extends undefined
    ? never
    : S extends partenaire_userArgs | partenaire_userFindManyArgs
    ?'include' extends U
    ? partenaire_user  & {
    [P in TrueKeys<S['include']>]:
        P extends 'mypartenaire' ? UsersGetPayload<S['include'][P]> | null :
        P extends 'user' ? UsersGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'mypartenaire' ? UsersGetPayload<S['select'][P]> | null :
        P extends 'user' ? UsersGetPayload<S['select'][P]> | null :  P extends keyof partenaire_user ? partenaire_user[P] : never
  } 
    : partenaire_user
  : partenaire_user


  type partenaire_userCountArgs = Merge<
    Omit<partenaire_userFindManyArgs, 'select' | 'include'> & {
      select?: Partenaire_userCountAggregateInputType | true
    }
  >

  export interface partenaire_userDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Partenaire_user that matches the filter.
     * @param {partenaire_userFindUniqueArgs} args - Arguments to find a Partenaire_user
     * @example
     * // Get one Partenaire_user
     * const partenaire_user = await prisma.partenaire_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends partenaire_userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, partenaire_userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'partenaire_user'> extends True ? CheckSelect<T, Prisma__partenaire_userClient<partenaire_user>, Prisma__partenaire_userClient<partenaire_userGetPayload<T>>> : CheckSelect<T, Prisma__partenaire_userClient<partenaire_user | null >, Prisma__partenaire_userClient<partenaire_userGetPayload<T> | null >>

    /**
     * Find the first Partenaire_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partenaire_userFindFirstArgs} args - Arguments to find a Partenaire_user
     * @example
     * // Get one Partenaire_user
     * const partenaire_user = await prisma.partenaire_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends partenaire_userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, partenaire_userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'partenaire_user'> extends True ? CheckSelect<T, Prisma__partenaire_userClient<partenaire_user>, Prisma__partenaire_userClient<partenaire_userGetPayload<T>>> : CheckSelect<T, Prisma__partenaire_userClient<partenaire_user | null >, Prisma__partenaire_userClient<partenaire_userGetPayload<T> | null >>

    /**
     * Find zero or more Partenaire_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partenaire_userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partenaire_users
     * const partenaire_users = await prisma.partenaire_user.findMany()
     * 
     * // Get first 10 Partenaire_users
     * const partenaire_users = await prisma.partenaire_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partenaire_userWithIdOnly = await prisma.partenaire_user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends partenaire_userFindManyArgs>(
      args?: SelectSubset<T, partenaire_userFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<partenaire_user>>, PrismaPromise<Array<partenaire_userGetPayload<T>>>>

    /**
     * Create a Partenaire_user.
     * @param {partenaire_userCreateArgs} args - Arguments to create a Partenaire_user.
     * @example
     * // Create one Partenaire_user
     * const Partenaire_user = await prisma.partenaire_user.create({
     *   data: {
     *     // ... data to create a Partenaire_user
     *   }
     * })
     * 
    **/
    create<T extends partenaire_userCreateArgs>(
      args: SelectSubset<T, partenaire_userCreateArgs>
    ): CheckSelect<T, Prisma__partenaire_userClient<partenaire_user>, Prisma__partenaire_userClient<partenaire_userGetPayload<T>>>

    /**
     * Create many Partenaire_users.
     *     @param {partenaire_userCreateManyArgs} args - Arguments to create many Partenaire_users.
     *     @example
     *     // Create many Partenaire_users
     *     const partenaire_user = await prisma.partenaire_user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends partenaire_userCreateManyArgs>(
      args?: SelectSubset<T, partenaire_userCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Partenaire_user.
     * @param {partenaire_userDeleteArgs} args - Arguments to delete one Partenaire_user.
     * @example
     * // Delete one Partenaire_user
     * const Partenaire_user = await prisma.partenaire_user.delete({
     *   where: {
     *     // ... filter to delete one Partenaire_user
     *   }
     * })
     * 
    **/
    delete<T extends partenaire_userDeleteArgs>(
      args: SelectSubset<T, partenaire_userDeleteArgs>
    ): CheckSelect<T, Prisma__partenaire_userClient<partenaire_user>, Prisma__partenaire_userClient<partenaire_userGetPayload<T>>>

    /**
     * Update one Partenaire_user.
     * @param {partenaire_userUpdateArgs} args - Arguments to update one Partenaire_user.
     * @example
     * // Update one Partenaire_user
     * const partenaire_user = await prisma.partenaire_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends partenaire_userUpdateArgs>(
      args: SelectSubset<T, partenaire_userUpdateArgs>
    ): CheckSelect<T, Prisma__partenaire_userClient<partenaire_user>, Prisma__partenaire_userClient<partenaire_userGetPayload<T>>>

    /**
     * Delete zero or more Partenaire_users.
     * @param {partenaire_userDeleteManyArgs} args - Arguments to filter Partenaire_users to delete.
     * @example
     * // Delete a few Partenaire_users
     * const { count } = await prisma.partenaire_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends partenaire_userDeleteManyArgs>(
      args?: SelectSubset<T, partenaire_userDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partenaire_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partenaire_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partenaire_users
     * const partenaire_user = await prisma.partenaire_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends partenaire_userUpdateManyArgs>(
      args: SelectSubset<T, partenaire_userUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Partenaire_user.
     * @param {partenaire_userUpsertArgs} args - Arguments to update or create a Partenaire_user.
     * @example
     * // Update or create a Partenaire_user
     * const partenaire_user = await prisma.partenaire_user.upsert({
     *   create: {
     *     // ... data to create a Partenaire_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partenaire_user we want to update
     *   }
     * })
    **/
    upsert<T extends partenaire_userUpsertArgs>(
      args: SelectSubset<T, partenaire_userUpsertArgs>
    ): CheckSelect<T, Prisma__partenaire_userClient<partenaire_user>, Prisma__partenaire_userClient<partenaire_userGetPayload<T>>>

    /**
     * Count the number of Partenaire_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partenaire_userCountArgs} args - Arguments to filter Partenaire_users to count.
     * @example
     * // Count the number of Partenaire_users
     * const count = await prisma.partenaire_user.count({
     *   where: {
     *     // ... the filter for the Partenaire_users we want to count
     *   }
     * })
    **/
    count<T extends partenaire_userCountArgs>(
      args?: Subset<T, partenaire_userCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Partenaire_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partenaire_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Partenaire_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Partenaire_userAggregateArgs>(args: Subset<T, Partenaire_userAggregateArgs>): PrismaPromise<GetPartenaire_userAggregateType<T>>

    /**
     * Group by Partenaire_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Partenaire_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Partenaire_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Partenaire_userGroupByArgs['orderBy'] }
        : { orderBy?: Partenaire_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Partenaire_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartenaire_userGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for partenaire_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__partenaire_userClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    mypartenaire<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    user<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * partenaire_user findUnique
   */
  export type partenaire_userFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
    /**
     * Throw an Error if a partenaire_user can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which partenaire_user to fetch.
     * 
    **/
    where: partenaire_userWhereUniqueInput
  }


  /**
   * partenaire_user findFirst
   */
  export type partenaire_userFindFirstArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
    /**
     * Throw an Error if a partenaire_user can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which partenaire_user to fetch.
     * 
    **/
    where?: partenaire_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partenaire_users to fetch.
     * 
    **/
    orderBy?: Enumerable<partenaire_userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for partenaire_users.
     * 
    **/
    cursor?: partenaire_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partenaire_users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partenaire_users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of partenaire_users.
     * 
    **/
    distinct?: Enumerable<Partenaire_userScalarFieldEnum>
  }


  /**
   * partenaire_user findMany
   */
  export type partenaire_userFindManyArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
    /**
     * Filter, which partenaire_users to fetch.
     * 
    **/
    where?: partenaire_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partenaire_users to fetch.
     * 
    **/
    orderBy?: Enumerable<partenaire_userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing partenaire_users.
     * 
    **/
    cursor?: partenaire_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partenaire_users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partenaire_users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Partenaire_userScalarFieldEnum>
  }


  /**
   * partenaire_user create
   */
  export type partenaire_userCreateArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
    /**
     * The data needed to create a partenaire_user.
     * 
    **/
    data: XOR<partenaire_userCreateInput, partenaire_userUncheckedCreateInput>
  }


  /**
   * partenaire_user createMany
   */
  export type partenaire_userCreateManyArgs = {
    /**
     * The data used to create many partenaire_users.
     * 
    **/
    data: Enumerable<partenaire_userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * partenaire_user update
   */
  export type partenaire_userUpdateArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
    /**
     * The data needed to update a partenaire_user.
     * 
    **/
    data: XOR<partenaire_userUpdateInput, partenaire_userUncheckedUpdateInput>
    /**
     * Choose, which partenaire_user to update.
     * 
    **/
    where: partenaire_userWhereUniqueInput
  }


  /**
   * partenaire_user updateMany
   */
  export type partenaire_userUpdateManyArgs = {
    /**
     * The data used to update partenaire_users.
     * 
    **/
    data: XOR<partenaire_userUpdateManyMutationInput, partenaire_userUncheckedUpdateManyInput>
    /**
     * Filter which partenaire_users to update
     * 
    **/
    where?: partenaire_userWhereInput
  }


  /**
   * partenaire_user upsert
   */
  export type partenaire_userUpsertArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
    /**
     * The filter to search for the partenaire_user to update in case it exists.
     * 
    **/
    where: partenaire_userWhereUniqueInput
    /**
     * In case the partenaire_user found by the `where` argument doesn't exist, create a new partenaire_user with this data.
     * 
    **/
    create: XOR<partenaire_userCreateInput, partenaire_userUncheckedCreateInput>
    /**
     * In case the partenaire_user was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<partenaire_userUpdateInput, partenaire_userUncheckedUpdateInput>
  }


  /**
   * partenaire_user delete
   */
  export type partenaire_userDeleteArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
    /**
     * Filter which partenaire_user to delete.
     * 
    **/
    where: partenaire_userWhereUniqueInput
  }


  /**
   * partenaire_user deleteMany
   */
  export type partenaire_userDeleteManyArgs = {
    /**
     * Filter which partenaire_users to delete
     * 
    **/
    where?: partenaire_userWhereInput
  }


  /**
   * partenaire_user without action
   */
  export type partenaire_userArgs = {
    /**
     * Select specific fields to fetch from the partenaire_user
     * 
    **/
    select?: partenaire_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: partenaire_userInclude | null
  }



  /**
   * Model mediatype
   */


  export type AggregateMediatype = {
    _count: MediatypeCountAggregateOutputType | null
    _avg: MediatypeAvgAggregateOutputType | null
    _sum: MediatypeSumAggregateOutputType | null
    _min: MediatypeMinAggregateOutputType | null
    _max: MediatypeMaxAggregateOutputType | null
  }

  export type MediatypeAvgAggregateOutputType = {
    id: number | null
  }

  export type MediatypeSumAggregateOutputType = {
    id: number | null
  }

  export type MediatypeMinAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type MediatypeMaxAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type MediatypeCountAggregateOutputType = {
    id: number
    libelle: number
    _all: number
  }


  export type MediatypeAvgAggregateInputType = {
    id?: true
  }

  export type MediatypeSumAggregateInputType = {
    id?: true
  }

  export type MediatypeMinAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type MediatypeMaxAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type MediatypeCountAggregateInputType = {
    id?: true
    libelle?: true
    _all?: true
  }

  export type MediatypeAggregateArgs = {
    /**
     * Filter which mediatype to aggregate.
     * 
    **/
    where?: mediatypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mediatypes to fetch.
     * 
    **/
    orderBy?: Enumerable<mediatypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mediatypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mediatypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mediatypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mediatypes
    **/
    _count?: true | MediatypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediatypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediatypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediatypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediatypeMaxAggregateInputType
  }

  export type GetMediatypeAggregateType<T extends MediatypeAggregateArgs> = {
        [P in keyof T & keyof AggregateMediatype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediatype[P]>
      : GetScalarType<T[P], AggregateMediatype[P]>
  }




  export type MediatypeGroupByArgs = {
    where?: mediatypeWhereInput
    orderBy?: Enumerable<mediatypeOrderByWithAggregationInput>
    by: Array<MediatypeScalarFieldEnum>
    having?: mediatypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediatypeCountAggregateInputType | true
    _avg?: MediatypeAvgAggregateInputType
    _sum?: MediatypeSumAggregateInputType
    _min?: MediatypeMinAggregateInputType
    _max?: MediatypeMaxAggregateInputType
  }


  export type MediatypeGroupByOutputType = {
    id: number
    libelle: string
    _count: MediatypeCountAggregateOutputType | null
    _avg: MediatypeAvgAggregateOutputType | null
    _sum: MediatypeSumAggregateOutputType | null
    _min: MediatypeMinAggregateOutputType | null
    _max: MediatypeMaxAggregateOutputType | null
  }

  type GetMediatypeGroupByPayload<T extends MediatypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MediatypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediatypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediatypeGroupByOutputType[P]>
            : GetScalarType<T[P], MediatypeGroupByOutputType[P]>
        }
      >
    >


  export type mediatypeSelect = {
    id?: boolean
    libelle?: boolean
    media?: boolean | mediaFindManyArgs
    _count?: boolean | MediatypeCountOutputTypeArgs
  }

  export type mediatypeInclude = {
    media?: boolean | mediaFindManyArgs
    _count?: boolean | MediatypeCountOutputTypeArgs
  }

  export type mediatypeGetPayload<
    S extends boolean | null | undefined | mediatypeArgs,
    U = keyof S
      > = S extends true
        ? mediatype
    : S extends undefined
    ? never
    : S extends mediatypeArgs | mediatypeFindManyArgs
    ?'include' extends U
    ? mediatype  & {
    [P in TrueKeys<S['include']>]:
        P extends 'media' ? Array < mediaGetPayload<S['include'][P]>>  :
        P extends '_count' ? MediatypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'media' ? Array < mediaGetPayload<S['select'][P]>>  :
        P extends '_count' ? MediatypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof mediatype ? mediatype[P] : never
  } 
    : mediatype
  : mediatype


  type mediatypeCountArgs = Merge<
    Omit<mediatypeFindManyArgs, 'select' | 'include'> & {
      select?: MediatypeCountAggregateInputType | true
    }
  >

  export interface mediatypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Mediatype that matches the filter.
     * @param {mediatypeFindUniqueArgs} args - Arguments to find a Mediatype
     * @example
     * // Get one Mediatype
     * const mediatype = await prisma.mediatype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mediatypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mediatypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mediatype'> extends True ? CheckSelect<T, Prisma__mediatypeClient<mediatype>, Prisma__mediatypeClient<mediatypeGetPayload<T>>> : CheckSelect<T, Prisma__mediatypeClient<mediatype | null >, Prisma__mediatypeClient<mediatypeGetPayload<T> | null >>

    /**
     * Find the first Mediatype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediatypeFindFirstArgs} args - Arguments to find a Mediatype
     * @example
     * // Get one Mediatype
     * const mediatype = await prisma.mediatype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mediatypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mediatypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mediatype'> extends True ? CheckSelect<T, Prisma__mediatypeClient<mediatype>, Prisma__mediatypeClient<mediatypeGetPayload<T>>> : CheckSelect<T, Prisma__mediatypeClient<mediatype | null >, Prisma__mediatypeClient<mediatypeGetPayload<T> | null >>

    /**
     * Find zero or more Mediatypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediatypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mediatypes
     * const mediatypes = await prisma.mediatype.findMany()
     * 
     * // Get first 10 Mediatypes
     * const mediatypes = await prisma.mediatype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediatypeWithIdOnly = await prisma.mediatype.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends mediatypeFindManyArgs>(
      args?: SelectSubset<T, mediatypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<mediatype>>, PrismaPromise<Array<mediatypeGetPayload<T>>>>

    /**
     * Create a Mediatype.
     * @param {mediatypeCreateArgs} args - Arguments to create a Mediatype.
     * @example
     * // Create one Mediatype
     * const Mediatype = await prisma.mediatype.create({
     *   data: {
     *     // ... data to create a Mediatype
     *   }
     * })
     * 
    **/
    create<T extends mediatypeCreateArgs>(
      args: SelectSubset<T, mediatypeCreateArgs>
    ): CheckSelect<T, Prisma__mediatypeClient<mediatype>, Prisma__mediatypeClient<mediatypeGetPayload<T>>>

    /**
     * Create many Mediatypes.
     *     @param {mediatypeCreateManyArgs} args - Arguments to create many Mediatypes.
     *     @example
     *     // Create many Mediatypes
     *     const mediatype = await prisma.mediatype.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mediatypeCreateManyArgs>(
      args?: SelectSubset<T, mediatypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mediatype.
     * @param {mediatypeDeleteArgs} args - Arguments to delete one Mediatype.
     * @example
     * // Delete one Mediatype
     * const Mediatype = await prisma.mediatype.delete({
     *   where: {
     *     // ... filter to delete one Mediatype
     *   }
     * })
     * 
    **/
    delete<T extends mediatypeDeleteArgs>(
      args: SelectSubset<T, mediatypeDeleteArgs>
    ): CheckSelect<T, Prisma__mediatypeClient<mediatype>, Prisma__mediatypeClient<mediatypeGetPayload<T>>>

    /**
     * Update one Mediatype.
     * @param {mediatypeUpdateArgs} args - Arguments to update one Mediatype.
     * @example
     * // Update one Mediatype
     * const mediatype = await prisma.mediatype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mediatypeUpdateArgs>(
      args: SelectSubset<T, mediatypeUpdateArgs>
    ): CheckSelect<T, Prisma__mediatypeClient<mediatype>, Prisma__mediatypeClient<mediatypeGetPayload<T>>>

    /**
     * Delete zero or more Mediatypes.
     * @param {mediatypeDeleteManyArgs} args - Arguments to filter Mediatypes to delete.
     * @example
     * // Delete a few Mediatypes
     * const { count } = await prisma.mediatype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mediatypeDeleteManyArgs>(
      args?: SelectSubset<T, mediatypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mediatypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediatypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mediatypes
     * const mediatype = await prisma.mediatype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mediatypeUpdateManyArgs>(
      args: SelectSubset<T, mediatypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mediatype.
     * @param {mediatypeUpsertArgs} args - Arguments to update or create a Mediatype.
     * @example
     * // Update or create a Mediatype
     * const mediatype = await prisma.mediatype.upsert({
     *   create: {
     *     // ... data to create a Mediatype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mediatype we want to update
     *   }
     * })
    **/
    upsert<T extends mediatypeUpsertArgs>(
      args: SelectSubset<T, mediatypeUpsertArgs>
    ): CheckSelect<T, Prisma__mediatypeClient<mediatype>, Prisma__mediatypeClient<mediatypeGetPayload<T>>>

    /**
     * Count the number of Mediatypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediatypeCountArgs} args - Arguments to filter Mediatypes to count.
     * @example
     * // Count the number of Mediatypes
     * const count = await prisma.mediatype.count({
     *   where: {
     *     // ... the filter for the Mediatypes we want to count
     *   }
     * })
    **/
    count<T extends mediatypeCountArgs>(
      args?: Subset<T, mediatypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediatypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mediatype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediatypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediatypeAggregateArgs>(args: Subset<T, MediatypeAggregateArgs>): PrismaPromise<GetMediatypeAggregateType<T>>

    /**
     * Group by Mediatype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediatypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediatypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediatypeGroupByArgs['orderBy'] }
        : { orderBy?: MediatypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediatypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediatypeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for mediatype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mediatypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    media<T extends mediaFindManyArgs = {}>(args?: Subset<T, mediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<media>>, PrismaPromise<Array<mediaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * mediatype findUnique
   */
  export type mediatypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
    /**
     * Throw an Error if a mediatype can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which mediatype to fetch.
     * 
    **/
    where: mediatypeWhereUniqueInput
  }


  /**
   * mediatype findFirst
   */
  export type mediatypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
    /**
     * Throw an Error if a mediatype can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which mediatype to fetch.
     * 
    **/
    where?: mediatypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mediatypes to fetch.
     * 
    **/
    orderBy?: Enumerable<mediatypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mediatypes.
     * 
    **/
    cursor?: mediatypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mediatypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mediatypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mediatypes.
     * 
    **/
    distinct?: Enumerable<MediatypeScalarFieldEnum>
  }


  /**
   * mediatype findMany
   */
  export type mediatypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
    /**
     * Filter, which mediatypes to fetch.
     * 
    **/
    where?: mediatypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mediatypes to fetch.
     * 
    **/
    orderBy?: Enumerable<mediatypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mediatypes.
     * 
    **/
    cursor?: mediatypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mediatypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mediatypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MediatypeScalarFieldEnum>
  }


  /**
   * mediatype create
   */
  export type mediatypeCreateArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
    /**
     * The data needed to create a mediatype.
     * 
    **/
    data: XOR<mediatypeCreateInput, mediatypeUncheckedCreateInput>
  }


  /**
   * mediatype createMany
   */
  export type mediatypeCreateManyArgs = {
    /**
     * The data used to create many mediatypes.
     * 
    **/
    data: Enumerable<mediatypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mediatype update
   */
  export type mediatypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
    /**
     * The data needed to update a mediatype.
     * 
    **/
    data: XOR<mediatypeUpdateInput, mediatypeUncheckedUpdateInput>
    /**
     * Choose, which mediatype to update.
     * 
    **/
    where: mediatypeWhereUniqueInput
  }


  /**
   * mediatype updateMany
   */
  export type mediatypeUpdateManyArgs = {
    /**
     * The data used to update mediatypes.
     * 
    **/
    data: XOR<mediatypeUpdateManyMutationInput, mediatypeUncheckedUpdateManyInput>
    /**
     * Filter which mediatypes to update
     * 
    **/
    where?: mediatypeWhereInput
  }


  /**
   * mediatype upsert
   */
  export type mediatypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
    /**
     * The filter to search for the mediatype to update in case it exists.
     * 
    **/
    where: mediatypeWhereUniqueInput
    /**
     * In case the mediatype found by the `where` argument doesn't exist, create a new mediatype with this data.
     * 
    **/
    create: XOR<mediatypeCreateInput, mediatypeUncheckedCreateInput>
    /**
     * In case the mediatype was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mediatypeUpdateInput, mediatypeUncheckedUpdateInput>
  }


  /**
   * mediatype delete
   */
  export type mediatypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
    /**
     * Filter which mediatype to delete.
     * 
    **/
    where: mediatypeWhereUniqueInput
  }


  /**
   * mediatype deleteMany
   */
  export type mediatypeDeleteManyArgs = {
    /**
     * Filter which mediatypes to delete
     * 
    **/
    where?: mediatypeWhereInput
  }


  /**
   * mediatype without action
   */
  export type mediatypeArgs = {
    /**
     * Select specific fields to fetch from the mediatype
     * 
    **/
    select?: mediatypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediatypeInclude | null
  }



  /**
   * Model media
   */


  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
    id_event: number | null
    id_user: number | null
    id_type: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: number | null
    id_event: number | null
    id_user: number | null
    id_type: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: number | null
    image: string | null
    id_event: number | null
    id_user: number | null
    id_type: number | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number | null
    image: string | null
    id_event: number | null
    id_user: number | null
    id_type: number | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    image: number
    id_event: number
    id_user: number
    id_type: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
    id_event?: true
    id_user?: true
    id_type?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
    id_event?: true
    id_user?: true
    id_type?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    image?: true
    id_event?: true
    id_user?: true
    id_type?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    image?: true
    id_event?: true
    id_user?: true
    id_type?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    image?: true
    id_event?: true
    id_user?: true
    id_type?: true
    _all?: true
  }

  export type MediaAggregateArgs = {
    /**
     * Filter which media to aggregate.
     * 
    **/
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     * 
    **/
    orderBy?: Enumerable<mediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs = {
    where?: mediaWhereInput
    orderBy?: Enumerable<mediaOrderByWithAggregationInput>
    by: Array<MediaScalarFieldEnum>
    having?: mediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }


  export type MediaGroupByOutputType = {
    id: number
    image: string
    id_event: number
    id_user: number
    id_type: number
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type mediaSelect = {
    id?: boolean
    image?: boolean
    id_event?: boolean
    id_user?: boolean
    id_type?: boolean
    user?: boolean | UsersArgs
    event?: boolean | evenementsArgs
    typeId?: boolean | mediatypeArgs
  }

  export type mediaInclude = {
    user?: boolean | UsersArgs
    event?: boolean | evenementsArgs
    typeId?: boolean | mediatypeArgs
  }

  export type mediaGetPayload<
    S extends boolean | null | undefined | mediaArgs,
    U = keyof S
      > = S extends true
        ? media
    : S extends undefined
    ? never
    : S extends mediaArgs | mediaFindManyArgs
    ?'include' extends U
    ? media  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UsersGetPayload<S['include'][P]> | null :
        P extends 'event' ? evenementsGetPayload<S['include'][P]> | null :
        P extends 'typeId' ? mediatypeGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UsersGetPayload<S['select'][P]> | null :
        P extends 'event' ? evenementsGetPayload<S['select'][P]> | null :
        P extends 'typeId' ? mediatypeGetPayload<S['select'][P]> | null :  P extends keyof media ? media[P] : never
  } 
    : media
  : media


  type mediaCountArgs = Merge<
    Omit<mediaFindManyArgs, 'select' | 'include'> & {
      select?: MediaCountAggregateInputType | true
    }
  >

  export interface mediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Media that matches the filter.
     * @param {mediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'media'> extends True ? CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>> : CheckSelect<T, Prisma__mediaClient<media | null >, Prisma__mediaClient<mediaGetPayload<T> | null >>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'media'> extends True ? CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>> : CheckSelect<T, Prisma__mediaClient<media | null >, Prisma__mediaClient<mediaGetPayload<T> | null >>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends mediaFindManyArgs>(
      args?: SelectSubset<T, mediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<media>>, PrismaPromise<Array<mediaGetPayload<T>>>>

    /**
     * Create a Media.
     * @param {mediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
    **/
    create<T extends mediaCreateArgs>(
      args: SelectSubset<T, mediaCreateArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Create many Media.
     *     @param {mediaCreateManyArgs} args - Arguments to create many Media.
     *     @example
     *     // Create many Media
     *     const media = await prisma.media.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mediaCreateManyArgs>(
      args?: SelectSubset<T, mediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {mediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
    **/
    delete<T extends mediaDeleteArgs>(
      args: SelectSubset<T, mediaDeleteArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Update one Media.
     * @param {mediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mediaUpdateArgs>(
      args: SelectSubset<T, mediaUpdateArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Delete zero or more Media.
     * @param {mediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mediaDeleteManyArgs>(
      args?: SelectSubset<T, mediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mediaUpdateManyArgs>(
      args: SelectSubset<T, mediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {mediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
    **/
    upsert<T extends mediaUpsertArgs>(
      args: SelectSubset<T, mediaUpsertArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends mediaCountArgs>(
      args?: Subset<T, mediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    event<T extends evenementsArgs = {}>(args?: Subset<T, evenementsArgs>): CheckSelect<T, Prisma__evenementsClient<evenements | null >, Prisma__evenementsClient<evenementsGetPayload<T> | null >>;

    typeId<T extends mediatypeArgs = {}>(args?: Subset<T, mediatypeArgs>): CheckSelect<T, Prisma__mediatypeClient<mediatype | null >, Prisma__mediatypeClient<mediatypeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * media findUnique
   */
  export type mediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Throw an Error if a media can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media to fetch.
     * 
    **/
    where: mediaWhereUniqueInput
  }


  /**
   * media findFirst
   */
  export type mediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Throw an Error if a media can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media to fetch.
     * 
    **/
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     * 
    **/
    orderBy?: Enumerable<mediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media.
     * 
    **/
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media.
     * 
    **/
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * media findMany
   */
  export type mediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Filter, which media to fetch.
     * 
    **/
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     * 
    **/
    orderBy?: Enumerable<mediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing media.
     * 
    **/
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * media create
   */
  export type mediaCreateArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * The data needed to create a media.
     * 
    **/
    data: XOR<mediaCreateInput, mediaUncheckedCreateInput>
  }


  /**
   * media createMany
   */
  export type mediaCreateManyArgs = {
    /**
     * The data used to create many media.
     * 
    **/
    data: Enumerable<mediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * media update
   */
  export type mediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * The data needed to update a media.
     * 
    **/
    data: XOR<mediaUpdateInput, mediaUncheckedUpdateInput>
    /**
     * Choose, which media to update.
     * 
    **/
    where: mediaWhereUniqueInput
  }


  /**
   * media updateMany
   */
  export type mediaUpdateManyArgs = {
    /**
     * The data used to update media.
     * 
    **/
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyInput>
    /**
     * Filter which media to update
     * 
    **/
    where?: mediaWhereInput
  }


  /**
   * media upsert
   */
  export type mediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * The filter to search for the media to update in case it exists.
     * 
    **/
    where: mediaWhereUniqueInput
    /**
     * In case the media found by the `where` argument doesn't exist, create a new media with this data.
     * 
    **/
    create: XOR<mediaCreateInput, mediaUncheckedCreateInput>
    /**
     * In case the media was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mediaUpdateInput, mediaUncheckedUpdateInput>
  }


  /**
   * media delete
   */
  export type mediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Filter which media to delete.
     * 
    **/
    where: mediaWhereUniqueInput
  }


  /**
   * media deleteMany
   */
  export type mediaDeleteManyArgs = {
    /**
     * Filter which media to delete
     * 
    **/
    where?: mediaWhereInput
  }


  /**
   * media without action
   */
  export type mediaArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const RolesScalarFieldEnum: {
    id: 'id',
    role: 'role'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    login: 'login',
    password: 'password',
    adresse: 'adresse',
    email: 'email',
    token: 'token',
    id_role: 'id_role'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const LieuScalarFieldEnum: {
    id: 'id',
    nomLieu: 'nomLieu',
    adresse: 'adresse'
  };

  export type LieuScalarFieldEnum = (typeof LieuScalarFieldEnum)[keyof typeof LieuScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    categorie: 'categorie'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const EvenementsScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    id_lieu: 'id_lieu',
    id_categorie: 'id_categorie',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    dateLimit: 'dateLimit',
    nbPlace: 'nbPlace',
    prix: 'prix',
    isPublic: 'isPublic'
  };

  export type EvenementsScalarFieldEnum = (typeof EvenementsScalarFieldEnum)[keyof typeof EvenementsScalarFieldEnum]


  export const Event_partenaireScalarFieldEnum: {
    id: 'id',
    id_event: 'id_event',
    id_partenaire: 'id_partenaire'
  };

  export type Event_partenaireScalarFieldEnum = (typeof Event_partenaireScalarFieldEnum)[keyof typeof Event_partenaireScalarFieldEnum]


  export const Partenaire_userScalarFieldEnum: {
    id: 'id',
    id_partenaire: 'id_partenaire',
    id_user: 'id_user'
  };

  export type Partenaire_userScalarFieldEnum = (typeof Partenaire_userScalarFieldEnum)[keyof typeof Partenaire_userScalarFieldEnum]


  export const MediatypeScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle'
  };

  export type MediatypeScalarFieldEnum = (typeof MediatypeScalarFieldEnum)[keyof typeof MediatypeScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    image: 'image',
    id_event: 'id_event',
    id_user: 'id_user',
    id_type: 'id_type'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type RolesWhereInput = {
    AND?: Enumerable<RolesWhereInput>
    OR?: Enumerable<RolesWhereInput>
    NOT?: Enumerable<RolesWhereInput>
    id?: IntFilter | number
    role?: StringFilter | string
    users?: UsersListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    users?: UsersOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = {
    id?: number
  }

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    role?: StringWithAggregatesFilter | string
  }

  export type UsersWhereInput = {
    AND?: Enumerable<UsersWhereInput>
    OR?: Enumerable<UsersWhereInput>
    NOT?: Enumerable<UsersWhereInput>
    id?: IntFilter | number
    nom?: StringFilter | string
    prenom?: StringFilter | string
    login?: StringFilter | string
    password?: StringFilter | string
    adresse?: StringFilter | string
    email?: StringFilter | string
    token?: StringFilter | string
    role?: XOR<RolesRelationFilter, RolesWhereInput> | null
    id_role?: IntFilter | number
    partenaire?: Event_partenaireListRelationFilter
    mypartenaire?: Partenaire_userListRelationFilter
    user?: Partenaire_userListRelationFilter
    media?: MediaListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    login?: SortOrder
    password?: SortOrder
    adresse?: SortOrder
    email?: SortOrder
    token?: SortOrder
    role?: RolesOrderByWithRelationInput
    id_role?: SortOrder
    partenaire?: event_partenaireOrderByRelationAggregateInput
    mypartenaire?: partenaire_userOrderByRelationAggregateInput
    user?: partenaire_userOrderByRelationAggregateInput
    media?: mediaOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = {
    id?: number
  }

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    login?: SortOrder
    password?: SortOrder
    adresse?: SortOrder
    email?: SortOrder
    token?: SortOrder
    id_role?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsersScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nom?: StringWithAggregatesFilter | string
    prenom?: StringWithAggregatesFilter | string
    login?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    adresse?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    id_role?: IntWithAggregatesFilter | number
  }

  export type LieuWhereInput = {
    AND?: Enumerable<LieuWhereInput>
    OR?: Enumerable<LieuWhereInput>
    NOT?: Enumerable<LieuWhereInput>
    id?: IntFilter | number
    nomLieu?: StringFilter | string
    adresse?: StringFilter | string
    events?: EvenementsListRelationFilter
  }

  export type LieuOrderByWithRelationInput = {
    id?: SortOrder
    nomLieu?: SortOrder
    adresse?: SortOrder
    events?: evenementsOrderByRelationAggregateInput
  }

  export type LieuWhereUniqueInput = {
    id?: number
  }

  export type LieuOrderByWithAggregationInput = {
    id?: SortOrder
    nomLieu?: SortOrder
    adresse?: SortOrder
    _count?: LieuCountOrderByAggregateInput
    _avg?: LieuAvgOrderByAggregateInput
    _max?: LieuMaxOrderByAggregateInput
    _min?: LieuMinOrderByAggregateInput
    _sum?: LieuSumOrderByAggregateInput
  }

  export type LieuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LieuScalarWhereWithAggregatesInput>
    OR?: Enumerable<LieuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LieuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nomLieu?: StringWithAggregatesFilter | string
    adresse?: StringWithAggregatesFilter | string
  }

  export type CategoriesWhereInput = {
    AND?: Enumerable<CategoriesWhereInput>
    OR?: Enumerable<CategoriesWhereInput>
    NOT?: Enumerable<CategoriesWhereInput>
    id?: IntFilter | number
    categorie?: StringFilter | string
    events?: EvenementsListRelationFilter
  }

  export type CategoriesOrderByWithRelationInput = {
    id?: SortOrder
    categorie?: SortOrder
    events?: evenementsOrderByRelationAggregateInput
  }

  export type CategoriesWhereUniqueInput = {
    id?: number
  }

  export type CategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    categorie?: SortOrder
    _count?: CategoriesCountOrderByAggregateInput
    _avg?: CategoriesAvgOrderByAggregateInput
    _max?: CategoriesMaxOrderByAggregateInput
    _min?: CategoriesMinOrderByAggregateInput
    _sum?: CategoriesSumOrderByAggregateInput
  }

  export type CategoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoriesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    categorie?: StringWithAggregatesFilter | string
  }

  export type evenementsWhereInput = {
    AND?: Enumerable<evenementsWhereInput>
    OR?: Enumerable<evenementsWhereInput>
    NOT?: Enumerable<evenementsWhereInput>
    id?: IntFilter | number
    nom?: StringFilter | string
    description?: StringFilter | string
    id_lieu?: IntFilter | number
    id_categorie?: IntFilter | number
    lieu?: XOR<LieuRelationFilter, LieuWhereInput> | null
    categorie?: XOR<CategoriesRelationFilter, CategoriesWhereInput> | null
    dateDebut?: DateTimeFilter | Date | string
    dateFin?: DateTimeFilter | Date | string
    dateLimit?: DateTimeFilter | Date | string
    nbPlace?: IntFilter | number
    prix?: IntFilter | number
    isPublic?: BoolFilter | boolean
    event?: Event_partenaireListRelationFilter
    media?: MediaListRelationFilter
  }

  export type evenementsOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    id_lieu?: SortOrder
    id_categorie?: SortOrder
    lieu?: LieuOrderByWithRelationInput
    categorie?: CategoriesOrderByWithRelationInput
    dateDebut?: SortOrder
    dateFin?: SortOrder
    dateLimit?: SortOrder
    nbPlace?: SortOrder
    prix?: SortOrder
    isPublic?: SortOrder
    event?: event_partenaireOrderByRelationAggregateInput
    media?: mediaOrderByRelationAggregateInput
  }

  export type evenementsWhereUniqueInput = {
    id?: number
  }

  export type evenementsOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    id_lieu?: SortOrder
    id_categorie?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    dateLimit?: SortOrder
    nbPlace?: SortOrder
    prix?: SortOrder
    isPublic?: SortOrder
    _count?: evenementsCountOrderByAggregateInput
    _avg?: evenementsAvgOrderByAggregateInput
    _max?: evenementsMaxOrderByAggregateInput
    _min?: evenementsMinOrderByAggregateInput
    _sum?: evenementsSumOrderByAggregateInput
  }

  export type evenementsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<evenementsScalarWhereWithAggregatesInput>
    OR?: Enumerable<evenementsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<evenementsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nom?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    id_lieu?: IntWithAggregatesFilter | number
    id_categorie?: IntWithAggregatesFilter | number
    dateDebut?: DateTimeWithAggregatesFilter | Date | string
    dateFin?: DateTimeWithAggregatesFilter | Date | string
    dateLimit?: DateTimeWithAggregatesFilter | Date | string
    nbPlace?: IntWithAggregatesFilter | number
    prix?: IntWithAggregatesFilter | number
    isPublic?: BoolWithAggregatesFilter | boolean
  }

  export type event_partenaireWhereInput = {
    AND?: Enumerable<event_partenaireWhereInput>
    OR?: Enumerable<event_partenaireWhereInput>
    NOT?: Enumerable<event_partenaireWhereInput>
    id?: IntFilter | number
    id_event?: IntFilter | number
    id_partenaire?: IntFilter | number
    event?: XOR<EvenementsRelationFilter, evenementsWhereInput> | null
    partenaire?: XOR<UsersRelationFilter, UsersWhereInput> | null
  }

  export type event_partenaireOrderByWithRelationInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_partenaire?: SortOrder
    event?: evenementsOrderByWithRelationInput
    partenaire?: UsersOrderByWithRelationInput
  }

  export type event_partenaireWhereUniqueInput = {
    id?: number
  }

  export type event_partenaireOrderByWithAggregationInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_partenaire?: SortOrder
    _count?: event_partenaireCountOrderByAggregateInput
    _avg?: event_partenaireAvgOrderByAggregateInput
    _max?: event_partenaireMaxOrderByAggregateInput
    _min?: event_partenaireMinOrderByAggregateInput
    _sum?: event_partenaireSumOrderByAggregateInput
  }

  export type event_partenaireScalarWhereWithAggregatesInput = {
    AND?: Enumerable<event_partenaireScalarWhereWithAggregatesInput>
    OR?: Enumerable<event_partenaireScalarWhereWithAggregatesInput>
    NOT?: Enumerable<event_partenaireScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    id_event?: IntWithAggregatesFilter | number
    id_partenaire?: IntWithAggregatesFilter | number
  }

  export type partenaire_userWhereInput = {
    AND?: Enumerable<partenaire_userWhereInput>
    OR?: Enumerable<partenaire_userWhereInput>
    NOT?: Enumerable<partenaire_userWhereInput>
    id?: IntFilter | number
    id_partenaire?: IntFilter | number
    mypartenaire?: XOR<UsersRelationFilter, UsersWhereInput> | null
    id_user?: IntFilter | number
    user?: XOR<UsersRelationFilter, UsersWhereInput> | null
  }

  export type partenaire_userOrderByWithRelationInput = {
    id?: SortOrder
    id_partenaire?: SortOrder
    mypartenaire?: UsersOrderByWithRelationInput
    id_user?: SortOrder
    user?: UsersOrderByWithRelationInput
  }

  export type partenaire_userWhereUniqueInput = {
    id?: number
  }

  export type partenaire_userOrderByWithAggregationInput = {
    id?: SortOrder
    id_partenaire?: SortOrder
    id_user?: SortOrder
    _count?: partenaire_userCountOrderByAggregateInput
    _avg?: partenaire_userAvgOrderByAggregateInput
    _max?: partenaire_userMaxOrderByAggregateInput
    _min?: partenaire_userMinOrderByAggregateInput
    _sum?: partenaire_userSumOrderByAggregateInput
  }

  export type partenaire_userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<partenaire_userScalarWhereWithAggregatesInput>
    OR?: Enumerable<partenaire_userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<partenaire_userScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    id_partenaire?: IntWithAggregatesFilter | number
    id_user?: IntWithAggregatesFilter | number
  }

  export type mediatypeWhereInput = {
    AND?: Enumerable<mediatypeWhereInput>
    OR?: Enumerable<mediatypeWhereInput>
    NOT?: Enumerable<mediatypeWhereInput>
    id?: IntFilter | number
    libelle?: StringFilter | string
    media?: MediaListRelationFilter
  }

  export type mediatypeOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    media?: mediaOrderByRelationAggregateInput
  }

  export type mediatypeWhereUniqueInput = {
    id?: number
  }

  export type mediatypeOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    _count?: mediatypeCountOrderByAggregateInput
    _avg?: mediatypeAvgOrderByAggregateInput
    _max?: mediatypeMaxOrderByAggregateInput
    _min?: mediatypeMinOrderByAggregateInput
    _sum?: mediatypeSumOrderByAggregateInput
  }

  export type mediatypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mediatypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<mediatypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mediatypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    libelle?: StringWithAggregatesFilter | string
  }

  export type mediaWhereInput = {
    AND?: Enumerable<mediaWhereInput>
    OR?: Enumerable<mediaWhereInput>
    NOT?: Enumerable<mediaWhereInput>
    id?: IntFilter | number
    image?: StringFilter | string
    id_event?: IntFilter | number
    id_user?: IntFilter | number
    id_type?: IntFilter | number
    user?: XOR<UsersRelationFilter, UsersWhereInput> | null
    event?: XOR<EvenementsRelationFilter, evenementsWhereInput> | null
    typeId?: XOR<MediatypeRelationFilter, mediatypeWhereInput> | null
  }

  export type mediaOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    id_event?: SortOrder
    id_user?: SortOrder
    id_type?: SortOrder
    user?: UsersOrderByWithRelationInput
    event?: evenementsOrderByWithRelationInput
    typeId?: mediatypeOrderByWithRelationInput
  }

  export type mediaWhereUniqueInput = {
    id?: number
  }

  export type mediaOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    id_event?: SortOrder
    id_user?: SortOrder
    id_type?: SortOrder
    _count?: mediaCountOrderByAggregateInput
    _avg?: mediaAvgOrderByAggregateInput
    _max?: mediaMaxOrderByAggregateInput
    _min?: mediaMinOrderByAggregateInput
    _sum?: mediaSumOrderByAggregateInput
  }

  export type mediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<mediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mediaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    image?: StringWithAggregatesFilter | string
    id_event?: IntWithAggregatesFilter | number
    id_user?: IntWithAggregatesFilter | number
    id_type?: IntWithAggregatesFilter | number
  }

  export type RolesCreateInput = {
    role: string
    users?: UsersCreateNestedManyWithoutRoleInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    role: string
    users?: UsersUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RolesUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateManyWithoutRoleInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    users?: UsersUncheckedUpdateManyWithoutRoleInput
  }

  export type RolesCreateManyInput = {
    id?: number
    role: string
  }

  export type RolesUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateInput = {
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    role?: RolesCreateNestedOneWithoutUsersInput
    partenaire?: event_partenaireCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    id_role: number
    partenaire?: event_partenaireUncheckedCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: RolesUpdateOneWithoutUsersInput
    partenaire?: event_partenaireUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    id_role?: IntFieldUpdateOperationsInput | number
    partenaire?: event_partenaireUncheckedUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
  }

  export type UsersCreateManyInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    id_role: number
  }

  export type UsersUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    id_role?: IntFieldUpdateOperationsInput | number
  }

  export type LieuCreateInput = {
    nomLieu: string
    adresse: string
    events?: evenementsCreateNestedManyWithoutLieuInput
  }

  export type LieuUncheckedCreateInput = {
    id?: number
    nomLieu: string
    adresse: string
    events?: evenementsUncheckedCreateNestedManyWithoutLieuInput
  }

  export type LieuUpdateInput = {
    nomLieu?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    events?: evenementsUpdateManyWithoutLieuInput
  }

  export type LieuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomLieu?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    events?: evenementsUncheckedUpdateManyWithoutLieuInput
  }

  export type LieuCreateManyInput = {
    id?: number
    nomLieu: string
    adresse: string
  }

  export type LieuUpdateManyMutationInput = {
    nomLieu?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
  }

  export type LieuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomLieu?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesCreateInput = {
    categorie: string
    events?: evenementsCreateNestedManyWithoutCategorieInput
  }

  export type CategoriesUncheckedCreateInput = {
    id?: number
    categorie: string
    events?: evenementsUncheckedCreateNestedManyWithoutCategorieInput
  }

  export type CategoriesUpdateInput = {
    categorie?: StringFieldUpdateOperationsInput | string
    events?: evenementsUpdateManyWithoutCategorieInput
  }

  export type CategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorie?: StringFieldUpdateOperationsInput | string
    events?: evenementsUncheckedUpdateManyWithoutCategorieInput
  }

  export type CategoriesCreateManyInput = {
    id?: number
    categorie: string
  }

  export type CategoriesUpdateManyMutationInput = {
    categorie?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorie?: StringFieldUpdateOperationsInput | string
  }

  export type evenementsCreateInput = {
    nom: string
    description: string
    lieu?: LieuCreateNestedOneWithoutEventsInput
    categorie?: CategoriesCreateNestedOneWithoutEventsInput
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireCreateNestedManyWithoutEventInput
    media?: mediaCreateNestedManyWithoutEventInput
  }

  export type evenementsUncheckedCreateInput = {
    id?: number
    nom: string
    description: string
    id_lieu: number
    id_categorie: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireUncheckedCreateNestedManyWithoutEventInput
    media?: mediaUncheckedCreateNestedManyWithoutEventInput
  }

  export type evenementsUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lieu?: LieuUpdateOneWithoutEventsInput
    categorie?: CategoriesUpdateOneWithoutEventsInput
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUpdateManyWithoutEventInput
    media?: mediaUpdateManyWithoutEventInput
  }

  export type evenementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    id_lieu?: IntFieldUpdateOperationsInput | number
    id_categorie?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUncheckedUpdateManyWithoutEventInput
    media?: mediaUncheckedUpdateManyWithoutEventInput
  }

  export type evenementsCreateManyInput = {
    id?: number
    nom: string
    description: string
    id_lieu: number
    id_categorie: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
  }

  export type evenementsUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type evenementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    id_lieu?: IntFieldUpdateOperationsInput | number
    id_categorie?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type event_partenaireCreateInput = {
    event?: evenementsCreateNestedOneWithoutEventInput
    partenaire?: UsersCreateNestedOneWithoutPartenaireInput
  }

  export type event_partenaireUncheckedCreateInput = {
    id?: number
    id_event: number
    id_partenaire: number
  }

  export type event_partenaireUpdateInput = {
    event?: evenementsUpdateOneWithoutEventInput
    partenaire?: UsersUpdateOneWithoutPartenaireInput
  }

  export type event_partenaireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_event?: IntFieldUpdateOperationsInput | number
    id_partenaire?: IntFieldUpdateOperationsInput | number
  }

  export type event_partenaireCreateManyInput = {
    id?: number
    id_event: number
    id_partenaire: number
  }

  export type event_partenaireUpdateManyMutationInput = {

  }

  export type event_partenaireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_event?: IntFieldUpdateOperationsInput | number
    id_partenaire?: IntFieldUpdateOperationsInput | number
  }

  export type partenaire_userCreateInput = {
    mypartenaire?: UsersCreateNestedOneWithoutMypartenaireInput
    user?: UsersCreateNestedOneWithoutUserInput
  }

  export type partenaire_userUncheckedCreateInput = {
    id?: number
    id_partenaire: number
    id_user: number
  }

  export type partenaire_userUpdateInput = {
    mypartenaire?: UsersUpdateOneWithoutMypartenaireInput
    user?: UsersUpdateOneWithoutUserInput
  }

  export type partenaire_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_partenaire?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type partenaire_userCreateManyInput = {
    id?: number
    id_partenaire: number
    id_user: number
  }

  export type partenaire_userUpdateManyMutationInput = {

  }

  export type partenaire_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_partenaire?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type mediatypeCreateInput = {
    libelle: string
    media?: mediaCreateNestedManyWithoutTypeIdInput
  }

  export type mediatypeUncheckedCreateInput = {
    id?: number
    libelle: string
    media?: mediaUncheckedCreateNestedManyWithoutTypeIdInput
  }

  export type mediatypeUpdateInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    media?: mediaUpdateManyWithoutTypeIdInput
  }

  export type mediatypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    media?: mediaUncheckedUpdateManyWithoutTypeIdInput
  }

  export type mediatypeCreateManyInput = {
    id?: number
    libelle: string
  }

  export type mediatypeUpdateManyMutationInput = {
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type mediatypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type mediaCreateInput = {
    image: string
    user?: UsersCreateNestedOneWithoutMediaInput
    event?: evenementsCreateNestedOneWithoutMediaInput
    typeId?: mediatypeCreateNestedOneWithoutMediaInput
  }

  export type mediaUncheckedCreateInput = {
    id?: number
    image: string
    id_event: number
    id_user: number
    id_type: number
  }

  export type mediaUpdateInput = {
    image?: StringFieldUpdateOperationsInput | string
    user?: UsersUpdateOneWithoutMediaInput
    event?: evenementsUpdateOneWithoutMediaInput
    typeId?: mediatypeUpdateOneWithoutMediaInput
  }

  export type mediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    id_event?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_type?: IntFieldUpdateOperationsInput | number
  }

  export type mediaCreateManyInput = {
    id?: number
    image: string
    id_event: number
    id_user: number
    id_type: number
  }

  export type mediaUpdateManyMutationInput = {
    image?: StringFieldUpdateOperationsInput | string
  }

  export type mediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    id_event?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_type?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type RolesRelationFilter = {
    is?: RolesWhereInput | null
    isNot?: RolesWhereInput | null
  }

  export type Event_partenaireListRelationFilter = {
    every?: event_partenaireWhereInput
    some?: event_partenaireWhereInput
    none?: event_partenaireWhereInput
  }

  export type Partenaire_userListRelationFilter = {
    every?: partenaire_userWhereInput
    some?: partenaire_userWhereInput
    none?: partenaire_userWhereInput
  }

  export type MediaListRelationFilter = {
    every?: mediaWhereInput
    some?: mediaWhereInput
    none?: mediaWhereInput
  }

  export type event_partenaireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type partenaire_userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    login?: SortOrder
    password?: SortOrder
    adresse?: SortOrder
    email?: SortOrder
    token?: SortOrder
    id_role?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
    id_role?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    login?: SortOrder
    password?: SortOrder
    adresse?: SortOrder
    email?: SortOrder
    token?: SortOrder
    id_role?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    login?: SortOrder
    password?: SortOrder
    adresse?: SortOrder
    email?: SortOrder
    token?: SortOrder
    id_role?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
    id_role?: SortOrder
  }

  export type EvenementsListRelationFilter = {
    every?: evenementsWhereInput
    some?: evenementsWhereInput
    none?: evenementsWhereInput
  }

  export type evenementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LieuCountOrderByAggregateInput = {
    id?: SortOrder
    nomLieu?: SortOrder
    adresse?: SortOrder
  }

  export type LieuAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LieuMaxOrderByAggregateInput = {
    id?: SortOrder
    nomLieu?: SortOrder
    adresse?: SortOrder
  }

  export type LieuMinOrderByAggregateInput = {
    id?: SortOrder
    nomLieu?: SortOrder
    adresse?: SortOrder
  }

  export type LieuSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    categorie?: SortOrder
  }

  export type CategoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    categorie?: SortOrder
  }

  export type CategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    categorie?: SortOrder
  }

  export type CategoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LieuRelationFilter = {
    is?: LieuWhereInput | null
    isNot?: LieuWhereInput | null
  }

  export type CategoriesRelationFilter = {
    is?: CategoriesWhereInput | null
    isNot?: CategoriesWhereInput | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type evenementsCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    id_lieu?: SortOrder
    id_categorie?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    dateLimit?: SortOrder
    nbPlace?: SortOrder
    prix?: SortOrder
    isPublic?: SortOrder
  }

  export type evenementsAvgOrderByAggregateInput = {
    id?: SortOrder
    id_lieu?: SortOrder
    id_categorie?: SortOrder
    nbPlace?: SortOrder
    prix?: SortOrder
  }

  export type evenementsMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    id_lieu?: SortOrder
    id_categorie?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    dateLimit?: SortOrder
    nbPlace?: SortOrder
    prix?: SortOrder
    isPublic?: SortOrder
  }

  export type evenementsMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    id_lieu?: SortOrder
    id_categorie?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    dateLimit?: SortOrder
    nbPlace?: SortOrder
    prix?: SortOrder
    isPublic?: SortOrder
  }

  export type evenementsSumOrderByAggregateInput = {
    id?: SortOrder
    id_lieu?: SortOrder
    id_categorie?: SortOrder
    nbPlace?: SortOrder
    prix?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EvenementsRelationFilter = {
    is?: evenementsWhereInput | null
    isNot?: evenementsWhereInput | null
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type event_partenaireCountOrderByAggregateInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_partenaire?: SortOrder
  }

  export type event_partenaireAvgOrderByAggregateInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_partenaire?: SortOrder
  }

  export type event_partenaireMaxOrderByAggregateInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_partenaire?: SortOrder
  }

  export type event_partenaireMinOrderByAggregateInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_partenaire?: SortOrder
  }

  export type event_partenaireSumOrderByAggregateInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_partenaire?: SortOrder
  }

  export type partenaire_userCountOrderByAggregateInput = {
    id?: SortOrder
    id_partenaire?: SortOrder
    id_user?: SortOrder
  }

  export type partenaire_userAvgOrderByAggregateInput = {
    id?: SortOrder
    id_partenaire?: SortOrder
    id_user?: SortOrder
  }

  export type partenaire_userMaxOrderByAggregateInput = {
    id?: SortOrder
    id_partenaire?: SortOrder
    id_user?: SortOrder
  }

  export type partenaire_userMinOrderByAggregateInput = {
    id?: SortOrder
    id_partenaire?: SortOrder
    id_user?: SortOrder
  }

  export type partenaire_userSumOrderByAggregateInput = {
    id?: SortOrder
    id_partenaire?: SortOrder
    id_user?: SortOrder
  }

  export type mediatypeCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type mediatypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type mediatypeMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type mediatypeMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type mediatypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MediatypeRelationFilter = {
    is?: mediatypeWhereInput | null
    isNot?: mediatypeWhereInput | null
  }

  export type mediaCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    id_event?: SortOrder
    id_user?: SortOrder
    id_type?: SortOrder
  }

  export type mediaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_user?: SortOrder
    id_type?: SortOrder
  }

  export type mediaMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    id_event?: SortOrder
    id_user?: SortOrder
    id_type?: SortOrder
  }

  export type mediaMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    id_event?: SortOrder
    id_user?: SortOrder
    id_type?: SortOrder
  }

  export type mediaSumOrderByAggregateInput = {
    id?: SortOrder
    id_event?: SortOrder
    id_user?: SortOrder
    id_type?: SortOrder
  }

  export type UsersCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UsersCreateWithoutRoleInput>, Enumerable<UsersUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutRoleInput>
    createMany?: UsersCreateManyRoleInputEnvelope
    connect?: Enumerable<UsersWhereUniqueInput>
  }

  export type UsersUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UsersCreateWithoutRoleInput>, Enumerable<UsersUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutRoleInput>
    createMany?: UsersCreateManyRoleInputEnvelope
    connect?: Enumerable<UsersWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UsersUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<UsersCreateWithoutRoleInput>, Enumerable<UsersUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UsersUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UsersCreateManyRoleInputEnvelope
    set?: Enumerable<UsersWhereUniqueInput>
    disconnect?: Enumerable<UsersWhereUniqueInput>
    delete?: Enumerable<UsersWhereUniqueInput>
    connect?: Enumerable<UsersWhereUniqueInput>
    update?: Enumerable<UsersUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UsersUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UsersScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsersUncheckedUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<UsersCreateWithoutRoleInput>, Enumerable<UsersUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UsersUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UsersCreateManyRoleInputEnvelope
    set?: Enumerable<UsersWhereUniqueInput>
    disconnect?: Enumerable<UsersWhereUniqueInput>
    delete?: Enumerable<UsersWhereUniqueInput>
    connect?: Enumerable<UsersWhereUniqueInput>
    update?: Enumerable<UsersUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UsersUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UsersScalarWhereInput>
  }

  export type RolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    connect?: RolesWhereUniqueInput
  }

  export type event_partenaireCreateNestedManyWithoutPartenaireInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutPartenaireInput>, Enumerable<event_partenaireUncheckedCreateWithoutPartenaireInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutPartenaireInput>
    createMany?: event_partenaireCreateManyPartenaireInputEnvelope
    connect?: Enumerable<event_partenaireWhereUniqueInput>
  }

  export type partenaire_userCreateNestedManyWithoutMypartenaireInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutMypartenaireInput>, Enumerable<partenaire_userUncheckedCreateWithoutMypartenaireInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutMypartenaireInput>
    createMany?: partenaire_userCreateManyMypartenaireInputEnvelope
    connect?: Enumerable<partenaire_userWhereUniqueInput>
  }

  export type partenaire_userCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutUserInput>, Enumerable<partenaire_userUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutUserInput>
    createMany?: partenaire_userCreateManyUserInputEnvelope
    connect?: Enumerable<partenaire_userWhereUniqueInput>
  }

  export type mediaCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type event_partenaireUncheckedCreateNestedManyWithoutPartenaireInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutPartenaireInput>, Enumerable<event_partenaireUncheckedCreateWithoutPartenaireInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutPartenaireInput>
    createMany?: event_partenaireCreateManyPartenaireInputEnvelope
    connect?: Enumerable<event_partenaireWhereUniqueInput>
  }

  export type partenaire_userUncheckedCreateNestedManyWithoutMypartenaireInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutMypartenaireInput>, Enumerable<partenaire_userUncheckedCreateWithoutMypartenaireInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutMypartenaireInput>
    createMany?: partenaire_userCreateManyMypartenaireInputEnvelope
    connect?: Enumerable<partenaire_userWhereUniqueInput>
  }

  export type partenaire_userUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutUserInput>, Enumerable<partenaire_userUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutUserInput>
    createMany?: partenaire_userCreateManyUserInputEnvelope
    connect?: Enumerable<partenaire_userWhereUniqueInput>
  }

  export type mediaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type RolesUpdateOneWithoutUsersInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    upsert?: RolesUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: RolesWhereUniqueInput
    update?: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type event_partenaireUpdateManyWithoutPartenaireInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutPartenaireInput>, Enumerable<event_partenaireUncheckedCreateWithoutPartenaireInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutPartenaireInput>
    upsert?: Enumerable<event_partenaireUpsertWithWhereUniqueWithoutPartenaireInput>
    createMany?: event_partenaireCreateManyPartenaireInputEnvelope
    set?: Enumerable<event_partenaireWhereUniqueInput>
    disconnect?: Enumerable<event_partenaireWhereUniqueInput>
    delete?: Enumerable<event_partenaireWhereUniqueInput>
    connect?: Enumerable<event_partenaireWhereUniqueInput>
    update?: Enumerable<event_partenaireUpdateWithWhereUniqueWithoutPartenaireInput>
    updateMany?: Enumerable<event_partenaireUpdateManyWithWhereWithoutPartenaireInput>
    deleteMany?: Enumerable<event_partenaireScalarWhereInput>
  }

  export type partenaire_userUpdateManyWithoutMypartenaireInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutMypartenaireInput>, Enumerable<partenaire_userUncheckedCreateWithoutMypartenaireInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutMypartenaireInput>
    upsert?: Enumerable<partenaire_userUpsertWithWhereUniqueWithoutMypartenaireInput>
    createMany?: partenaire_userCreateManyMypartenaireInputEnvelope
    set?: Enumerable<partenaire_userWhereUniqueInput>
    disconnect?: Enumerable<partenaire_userWhereUniqueInput>
    delete?: Enumerable<partenaire_userWhereUniqueInput>
    connect?: Enumerable<partenaire_userWhereUniqueInput>
    update?: Enumerable<partenaire_userUpdateWithWhereUniqueWithoutMypartenaireInput>
    updateMany?: Enumerable<partenaire_userUpdateManyWithWhereWithoutMypartenaireInput>
    deleteMany?: Enumerable<partenaire_userScalarWhereInput>
  }

  export type partenaire_userUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutUserInput>, Enumerable<partenaire_userUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<partenaire_userUpsertWithWhereUniqueWithoutUserInput>
    createMany?: partenaire_userCreateManyUserInputEnvelope
    set?: Enumerable<partenaire_userWhereUniqueInput>
    disconnect?: Enumerable<partenaire_userWhereUniqueInput>
    delete?: Enumerable<partenaire_userWhereUniqueInput>
    connect?: Enumerable<partenaire_userWhereUniqueInput>
    update?: Enumerable<partenaire_userUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<partenaire_userUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<partenaire_userScalarWhereInput>
  }

  export type mediaUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type event_partenaireUncheckedUpdateManyWithoutPartenaireInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutPartenaireInput>, Enumerable<event_partenaireUncheckedCreateWithoutPartenaireInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutPartenaireInput>
    upsert?: Enumerable<event_partenaireUpsertWithWhereUniqueWithoutPartenaireInput>
    createMany?: event_partenaireCreateManyPartenaireInputEnvelope
    set?: Enumerable<event_partenaireWhereUniqueInput>
    disconnect?: Enumerable<event_partenaireWhereUniqueInput>
    delete?: Enumerable<event_partenaireWhereUniqueInput>
    connect?: Enumerable<event_partenaireWhereUniqueInput>
    update?: Enumerable<event_partenaireUpdateWithWhereUniqueWithoutPartenaireInput>
    updateMany?: Enumerable<event_partenaireUpdateManyWithWhereWithoutPartenaireInput>
    deleteMany?: Enumerable<event_partenaireScalarWhereInput>
  }

  export type partenaire_userUncheckedUpdateManyWithoutMypartenaireInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutMypartenaireInput>, Enumerable<partenaire_userUncheckedCreateWithoutMypartenaireInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutMypartenaireInput>
    upsert?: Enumerable<partenaire_userUpsertWithWhereUniqueWithoutMypartenaireInput>
    createMany?: partenaire_userCreateManyMypartenaireInputEnvelope
    set?: Enumerable<partenaire_userWhereUniqueInput>
    disconnect?: Enumerable<partenaire_userWhereUniqueInput>
    delete?: Enumerable<partenaire_userWhereUniqueInput>
    connect?: Enumerable<partenaire_userWhereUniqueInput>
    update?: Enumerable<partenaire_userUpdateWithWhereUniqueWithoutMypartenaireInput>
    updateMany?: Enumerable<partenaire_userUpdateManyWithWhereWithoutMypartenaireInput>
    deleteMany?: Enumerable<partenaire_userScalarWhereInput>
  }

  export type partenaire_userUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<partenaire_userCreateWithoutUserInput>, Enumerable<partenaire_userUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<partenaire_userCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<partenaire_userUpsertWithWhereUniqueWithoutUserInput>
    createMany?: partenaire_userCreateManyUserInputEnvelope
    set?: Enumerable<partenaire_userWhereUniqueInput>
    disconnect?: Enumerable<partenaire_userWhereUniqueInput>
    delete?: Enumerable<partenaire_userWhereUniqueInput>
    connect?: Enumerable<partenaire_userWhereUniqueInput>
    update?: Enumerable<partenaire_userUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<partenaire_userUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<partenaire_userScalarWhereInput>
  }

  export type mediaUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type evenementsCreateNestedManyWithoutLieuInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutLieuInput>, Enumerable<evenementsUncheckedCreateWithoutLieuInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutLieuInput>
    createMany?: evenementsCreateManyLieuInputEnvelope
    connect?: Enumerable<evenementsWhereUniqueInput>
  }

  export type evenementsUncheckedCreateNestedManyWithoutLieuInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutLieuInput>, Enumerable<evenementsUncheckedCreateWithoutLieuInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutLieuInput>
    createMany?: evenementsCreateManyLieuInputEnvelope
    connect?: Enumerable<evenementsWhereUniqueInput>
  }

  export type evenementsUpdateManyWithoutLieuInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutLieuInput>, Enumerable<evenementsUncheckedCreateWithoutLieuInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutLieuInput>
    upsert?: Enumerable<evenementsUpsertWithWhereUniqueWithoutLieuInput>
    createMany?: evenementsCreateManyLieuInputEnvelope
    set?: Enumerable<evenementsWhereUniqueInput>
    disconnect?: Enumerable<evenementsWhereUniqueInput>
    delete?: Enumerable<evenementsWhereUniqueInput>
    connect?: Enumerable<evenementsWhereUniqueInput>
    update?: Enumerable<evenementsUpdateWithWhereUniqueWithoutLieuInput>
    updateMany?: Enumerable<evenementsUpdateManyWithWhereWithoutLieuInput>
    deleteMany?: Enumerable<evenementsScalarWhereInput>
  }

  export type evenementsUncheckedUpdateManyWithoutLieuInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutLieuInput>, Enumerable<evenementsUncheckedCreateWithoutLieuInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutLieuInput>
    upsert?: Enumerable<evenementsUpsertWithWhereUniqueWithoutLieuInput>
    createMany?: evenementsCreateManyLieuInputEnvelope
    set?: Enumerable<evenementsWhereUniqueInput>
    disconnect?: Enumerable<evenementsWhereUniqueInput>
    delete?: Enumerable<evenementsWhereUniqueInput>
    connect?: Enumerable<evenementsWhereUniqueInput>
    update?: Enumerable<evenementsUpdateWithWhereUniqueWithoutLieuInput>
    updateMany?: Enumerable<evenementsUpdateManyWithWhereWithoutLieuInput>
    deleteMany?: Enumerable<evenementsScalarWhereInput>
  }

  export type evenementsCreateNestedManyWithoutCategorieInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutCategorieInput>, Enumerable<evenementsUncheckedCreateWithoutCategorieInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutCategorieInput>
    createMany?: evenementsCreateManyCategorieInputEnvelope
    connect?: Enumerable<evenementsWhereUniqueInput>
  }

  export type evenementsUncheckedCreateNestedManyWithoutCategorieInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutCategorieInput>, Enumerable<evenementsUncheckedCreateWithoutCategorieInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutCategorieInput>
    createMany?: evenementsCreateManyCategorieInputEnvelope
    connect?: Enumerable<evenementsWhereUniqueInput>
  }

  export type evenementsUpdateManyWithoutCategorieInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutCategorieInput>, Enumerable<evenementsUncheckedCreateWithoutCategorieInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutCategorieInput>
    upsert?: Enumerable<evenementsUpsertWithWhereUniqueWithoutCategorieInput>
    createMany?: evenementsCreateManyCategorieInputEnvelope
    set?: Enumerable<evenementsWhereUniqueInput>
    disconnect?: Enumerable<evenementsWhereUniqueInput>
    delete?: Enumerable<evenementsWhereUniqueInput>
    connect?: Enumerable<evenementsWhereUniqueInput>
    update?: Enumerable<evenementsUpdateWithWhereUniqueWithoutCategorieInput>
    updateMany?: Enumerable<evenementsUpdateManyWithWhereWithoutCategorieInput>
    deleteMany?: Enumerable<evenementsScalarWhereInput>
  }

  export type evenementsUncheckedUpdateManyWithoutCategorieInput = {
    create?: XOR<Enumerable<evenementsCreateWithoutCategorieInput>, Enumerable<evenementsUncheckedCreateWithoutCategorieInput>>
    connectOrCreate?: Enumerable<evenementsCreateOrConnectWithoutCategorieInput>
    upsert?: Enumerable<evenementsUpsertWithWhereUniqueWithoutCategorieInput>
    createMany?: evenementsCreateManyCategorieInputEnvelope
    set?: Enumerable<evenementsWhereUniqueInput>
    disconnect?: Enumerable<evenementsWhereUniqueInput>
    delete?: Enumerable<evenementsWhereUniqueInput>
    connect?: Enumerable<evenementsWhereUniqueInput>
    update?: Enumerable<evenementsUpdateWithWhereUniqueWithoutCategorieInput>
    updateMany?: Enumerable<evenementsUpdateManyWithWhereWithoutCategorieInput>
    deleteMany?: Enumerable<evenementsScalarWhereInput>
  }

  export type LieuCreateNestedOneWithoutEventsInput = {
    create?: XOR<LieuCreateWithoutEventsInput, LieuUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LieuCreateOrConnectWithoutEventsInput
    connect?: LieuWhereUniqueInput
  }

  export type CategoriesCreateNestedOneWithoutEventsInput = {
    create?: XOR<CategoriesCreateWithoutEventsInput, CategoriesUncheckedCreateWithoutEventsInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutEventsInput
    connect?: CategoriesWhereUniqueInput
  }

  export type event_partenaireCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutEventInput>, Enumerable<event_partenaireUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutEventInput>
    createMany?: event_partenaireCreateManyEventInputEnvelope
    connect?: Enumerable<event_partenaireWhereUniqueInput>
  }

  export type mediaCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<mediaCreateWithoutEventInput>, Enumerable<mediaUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutEventInput>
    createMany?: mediaCreateManyEventInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type event_partenaireUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutEventInput>, Enumerable<event_partenaireUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutEventInput>
    createMany?: event_partenaireCreateManyEventInputEnvelope
    connect?: Enumerable<event_partenaireWhereUniqueInput>
  }

  export type mediaUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<mediaCreateWithoutEventInput>, Enumerable<mediaUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutEventInput>
    createMany?: mediaCreateManyEventInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type LieuUpdateOneWithoutEventsInput = {
    create?: XOR<LieuCreateWithoutEventsInput, LieuUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LieuCreateOrConnectWithoutEventsInput
    upsert?: LieuUpsertWithoutEventsInput
    disconnect?: boolean
    delete?: boolean
    connect?: LieuWhereUniqueInput
    update?: XOR<LieuUpdateWithoutEventsInput, LieuUncheckedUpdateWithoutEventsInput>
  }

  export type CategoriesUpdateOneWithoutEventsInput = {
    create?: XOR<CategoriesCreateWithoutEventsInput, CategoriesUncheckedCreateWithoutEventsInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutEventsInput
    upsert?: CategoriesUpsertWithoutEventsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CategoriesWhereUniqueInput
    update?: XOR<CategoriesUpdateWithoutEventsInput, CategoriesUncheckedUpdateWithoutEventsInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type event_partenaireUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutEventInput>, Enumerable<event_partenaireUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<event_partenaireUpsertWithWhereUniqueWithoutEventInput>
    createMany?: event_partenaireCreateManyEventInputEnvelope
    set?: Enumerable<event_partenaireWhereUniqueInput>
    disconnect?: Enumerable<event_partenaireWhereUniqueInput>
    delete?: Enumerable<event_partenaireWhereUniqueInput>
    connect?: Enumerable<event_partenaireWhereUniqueInput>
    update?: Enumerable<event_partenaireUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<event_partenaireUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<event_partenaireScalarWhereInput>
  }

  export type mediaUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<mediaCreateWithoutEventInput>, Enumerable<mediaUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutEventInput>
    createMany?: mediaCreateManyEventInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type event_partenaireUncheckedUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<event_partenaireCreateWithoutEventInput>, Enumerable<event_partenaireUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<event_partenaireCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<event_partenaireUpsertWithWhereUniqueWithoutEventInput>
    createMany?: event_partenaireCreateManyEventInputEnvelope
    set?: Enumerable<event_partenaireWhereUniqueInput>
    disconnect?: Enumerable<event_partenaireWhereUniqueInput>
    delete?: Enumerable<event_partenaireWhereUniqueInput>
    connect?: Enumerable<event_partenaireWhereUniqueInput>
    update?: Enumerable<event_partenaireUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<event_partenaireUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<event_partenaireScalarWhereInput>
  }

  export type mediaUncheckedUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<mediaCreateWithoutEventInput>, Enumerable<mediaUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutEventInput>
    createMany?: mediaCreateManyEventInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type evenementsCreateNestedOneWithoutEventInput = {
    create?: XOR<evenementsCreateWithoutEventInput, evenementsUncheckedCreateWithoutEventInput>
    connectOrCreate?: evenementsCreateOrConnectWithoutEventInput
    connect?: evenementsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutPartenaireInput = {
    create?: XOR<UsersCreateWithoutPartenaireInput, UsersUncheckedCreateWithoutPartenaireInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPartenaireInput
    connect?: UsersWhereUniqueInput
  }

  export type evenementsUpdateOneWithoutEventInput = {
    create?: XOR<evenementsCreateWithoutEventInput, evenementsUncheckedCreateWithoutEventInput>
    connectOrCreate?: evenementsCreateOrConnectWithoutEventInput
    upsert?: evenementsUpsertWithoutEventInput
    disconnect?: boolean
    delete?: boolean
    connect?: evenementsWhereUniqueInput
    update?: XOR<evenementsUpdateWithoutEventInput, evenementsUncheckedUpdateWithoutEventInput>
  }

  export type UsersUpdateOneWithoutPartenaireInput = {
    create?: XOR<UsersCreateWithoutPartenaireInput, UsersUncheckedCreateWithoutPartenaireInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPartenaireInput
    upsert?: UsersUpsertWithoutPartenaireInput
    disconnect?: boolean
    delete?: boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutPartenaireInput, UsersUncheckedUpdateWithoutPartenaireInput>
  }

  export type UsersCreateNestedOneWithoutMypartenaireInput = {
    create?: XOR<UsersCreateWithoutMypartenaireInput, UsersUncheckedCreateWithoutMypartenaireInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMypartenaireInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUserInput = {
    create?: XOR<UsersCreateWithoutUserInput, UsersUncheckedCreateWithoutUserInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneWithoutMypartenaireInput = {
    create?: XOR<UsersCreateWithoutMypartenaireInput, UsersUncheckedCreateWithoutMypartenaireInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMypartenaireInput
    upsert?: UsersUpsertWithoutMypartenaireInput
    disconnect?: boolean
    delete?: boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutMypartenaireInput, UsersUncheckedUpdateWithoutMypartenaireInput>
  }

  export type UsersUpdateOneWithoutUserInput = {
    create?: XOR<UsersCreateWithoutUserInput, UsersUncheckedCreateWithoutUserInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserInput
    upsert?: UsersUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutUserInput, UsersUncheckedUpdateWithoutUserInput>
  }

  export type mediaCreateNestedManyWithoutTypeIdInput = {
    create?: XOR<Enumerable<mediaCreateWithoutTypeIdInput>, Enumerable<mediaUncheckedCreateWithoutTypeIdInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutTypeIdInput>
    createMany?: mediaCreateManyTypeIdInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type mediaUncheckedCreateNestedManyWithoutTypeIdInput = {
    create?: XOR<Enumerable<mediaCreateWithoutTypeIdInput>, Enumerable<mediaUncheckedCreateWithoutTypeIdInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutTypeIdInput>
    createMany?: mediaCreateManyTypeIdInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type mediaUpdateManyWithoutTypeIdInput = {
    create?: XOR<Enumerable<mediaCreateWithoutTypeIdInput>, Enumerable<mediaUncheckedCreateWithoutTypeIdInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutTypeIdInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutTypeIdInput>
    createMany?: mediaCreateManyTypeIdInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutTypeIdInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutTypeIdInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type mediaUncheckedUpdateManyWithoutTypeIdInput = {
    create?: XOR<Enumerable<mediaCreateWithoutTypeIdInput>, Enumerable<mediaUncheckedCreateWithoutTypeIdInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutTypeIdInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutTypeIdInput>
    createMany?: mediaCreateManyTypeIdInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutTypeIdInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutTypeIdInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type UsersCreateNestedOneWithoutMediaInput = {
    create?: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMediaInput
    connect?: UsersWhereUniqueInput
  }

  export type evenementsCreateNestedOneWithoutMediaInput = {
    create?: XOR<evenementsCreateWithoutMediaInput, evenementsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: evenementsCreateOrConnectWithoutMediaInput
    connect?: evenementsWhereUniqueInput
  }

  export type mediatypeCreateNestedOneWithoutMediaInput = {
    create?: XOR<mediatypeCreateWithoutMediaInput, mediatypeUncheckedCreateWithoutMediaInput>
    connectOrCreate?: mediatypeCreateOrConnectWithoutMediaInput
    connect?: mediatypeWhereUniqueInput
  }

  export type UsersUpdateOneWithoutMediaInput = {
    create?: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMediaInput
    upsert?: UsersUpsertWithoutMediaInput
    disconnect?: boolean
    delete?: boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutMediaInput, UsersUncheckedUpdateWithoutMediaInput>
  }

  export type evenementsUpdateOneWithoutMediaInput = {
    create?: XOR<evenementsCreateWithoutMediaInput, evenementsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: evenementsCreateOrConnectWithoutMediaInput
    upsert?: evenementsUpsertWithoutMediaInput
    disconnect?: boolean
    delete?: boolean
    connect?: evenementsWhereUniqueInput
    update?: XOR<evenementsUpdateWithoutMediaInput, evenementsUncheckedUpdateWithoutMediaInput>
  }

  export type mediatypeUpdateOneWithoutMediaInput = {
    create?: XOR<mediatypeCreateWithoutMediaInput, mediatypeUncheckedCreateWithoutMediaInput>
    connectOrCreate?: mediatypeCreateOrConnectWithoutMediaInput
    upsert?: mediatypeUpsertWithoutMediaInput
    disconnect?: boolean
    delete?: boolean
    connect?: mediatypeWhereUniqueInput
    update?: XOR<mediatypeUpdateWithoutMediaInput, mediatypeUncheckedUpdateWithoutMediaInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type UsersCreateWithoutRoleInput = {
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    partenaire?: event_partenaireCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutRoleInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    partenaire?: event_partenaireUncheckedCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutRoleInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput>
  }

  export type UsersCreateManyRoleInputEnvelope = {
    data: Enumerable<UsersCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutRoleInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutRoleInput, UsersUncheckedUpdateWithoutRoleInput>
    create: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutRoleInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutRoleInput, UsersUncheckedUpdateWithoutRoleInput>
  }

  export type UsersUpdateManyWithWhereWithoutRoleInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutUsersInput>
  }

  export type UsersScalarWhereInput = {
    AND?: Enumerable<UsersScalarWhereInput>
    OR?: Enumerable<UsersScalarWhereInput>
    NOT?: Enumerable<UsersScalarWhereInput>
    id?: IntFilter | number
    nom?: StringFilter | string
    prenom?: StringFilter | string
    login?: StringFilter | string
    password?: StringFilter | string
    adresse?: StringFilter | string
    email?: StringFilter | string
    token?: StringFilter | string
    id_role?: IntFilter | number
  }

  export type RolesCreateWithoutUsersInput = {
    role: string
  }

  export type RolesUncheckedCreateWithoutUsersInput = {
    id?: number
    role: string
  }

  export type RolesCreateOrConnectWithoutUsersInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
  }

  export type event_partenaireCreateWithoutPartenaireInput = {
    event?: evenementsCreateNestedOneWithoutEventInput
  }

  export type event_partenaireUncheckedCreateWithoutPartenaireInput = {
    id?: number
    id_event: number
  }

  export type event_partenaireCreateOrConnectWithoutPartenaireInput = {
    where: event_partenaireWhereUniqueInput
    create: XOR<event_partenaireCreateWithoutPartenaireInput, event_partenaireUncheckedCreateWithoutPartenaireInput>
  }

  export type event_partenaireCreateManyPartenaireInputEnvelope = {
    data: Enumerable<event_partenaireCreateManyPartenaireInput>
    skipDuplicates?: boolean
  }

  export type partenaire_userCreateWithoutMypartenaireInput = {
    user?: UsersCreateNestedOneWithoutUserInput
  }

  export type partenaire_userUncheckedCreateWithoutMypartenaireInput = {
    id?: number
    id_user: number
  }

  export type partenaire_userCreateOrConnectWithoutMypartenaireInput = {
    where: partenaire_userWhereUniqueInput
    create: XOR<partenaire_userCreateWithoutMypartenaireInput, partenaire_userUncheckedCreateWithoutMypartenaireInput>
  }

  export type partenaire_userCreateManyMypartenaireInputEnvelope = {
    data: Enumerable<partenaire_userCreateManyMypartenaireInput>
    skipDuplicates?: boolean
  }

  export type partenaire_userCreateWithoutUserInput = {
    mypartenaire?: UsersCreateNestedOneWithoutMypartenaireInput
  }

  export type partenaire_userUncheckedCreateWithoutUserInput = {
    id?: number
    id_partenaire: number
  }

  export type partenaire_userCreateOrConnectWithoutUserInput = {
    where: partenaire_userWhereUniqueInput
    create: XOR<partenaire_userCreateWithoutUserInput, partenaire_userUncheckedCreateWithoutUserInput>
  }

  export type partenaire_userCreateManyUserInputEnvelope = {
    data: Enumerable<partenaire_userCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type mediaCreateWithoutUserInput = {
    image: string
    event?: evenementsCreateNestedOneWithoutMediaInput
    typeId?: mediatypeCreateNestedOneWithoutMediaInput
  }

  export type mediaUncheckedCreateWithoutUserInput = {
    id?: number
    image: string
    id_event: number
    id_type: number
  }

  export type mediaCreateOrConnectWithoutUserInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutUserInput, mediaUncheckedCreateWithoutUserInput>
  }

  export type mediaCreateManyUserInputEnvelope = {
    data: Enumerable<mediaCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RolesUpsertWithoutUsersInput = {
    update: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
  }

  export type RolesUpdateWithoutUsersInput = {
    role?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type event_partenaireUpsertWithWhereUniqueWithoutPartenaireInput = {
    where: event_partenaireWhereUniqueInput
    update: XOR<event_partenaireUpdateWithoutPartenaireInput, event_partenaireUncheckedUpdateWithoutPartenaireInput>
    create: XOR<event_partenaireCreateWithoutPartenaireInput, event_partenaireUncheckedCreateWithoutPartenaireInput>
  }

  export type event_partenaireUpdateWithWhereUniqueWithoutPartenaireInput = {
    where: event_partenaireWhereUniqueInput
    data: XOR<event_partenaireUpdateWithoutPartenaireInput, event_partenaireUncheckedUpdateWithoutPartenaireInput>
  }

  export type event_partenaireUpdateManyWithWhereWithoutPartenaireInput = {
    where: event_partenaireScalarWhereInput
    data: XOR<event_partenaireUpdateManyMutationInput, event_partenaireUncheckedUpdateManyWithoutPartenaireInput>
  }

  export type event_partenaireScalarWhereInput = {
    AND?: Enumerable<event_partenaireScalarWhereInput>
    OR?: Enumerable<event_partenaireScalarWhereInput>
    NOT?: Enumerable<event_partenaireScalarWhereInput>
    id?: IntFilter | number
    id_event?: IntFilter | number
    id_partenaire?: IntFilter | number
  }

  export type partenaire_userUpsertWithWhereUniqueWithoutMypartenaireInput = {
    where: partenaire_userWhereUniqueInput
    update: XOR<partenaire_userUpdateWithoutMypartenaireInput, partenaire_userUncheckedUpdateWithoutMypartenaireInput>
    create: XOR<partenaire_userCreateWithoutMypartenaireInput, partenaire_userUncheckedCreateWithoutMypartenaireInput>
  }

  export type partenaire_userUpdateWithWhereUniqueWithoutMypartenaireInput = {
    where: partenaire_userWhereUniqueInput
    data: XOR<partenaire_userUpdateWithoutMypartenaireInput, partenaire_userUncheckedUpdateWithoutMypartenaireInput>
  }

  export type partenaire_userUpdateManyWithWhereWithoutMypartenaireInput = {
    where: partenaire_userScalarWhereInput
    data: XOR<partenaire_userUpdateManyMutationInput, partenaire_userUncheckedUpdateManyWithoutMypartenaireInput>
  }

  export type partenaire_userScalarWhereInput = {
    AND?: Enumerable<partenaire_userScalarWhereInput>
    OR?: Enumerable<partenaire_userScalarWhereInput>
    NOT?: Enumerable<partenaire_userScalarWhereInput>
    id?: IntFilter | number
    id_partenaire?: IntFilter | number
    id_user?: IntFilter | number
  }

  export type partenaire_userUpsertWithWhereUniqueWithoutUserInput = {
    where: partenaire_userWhereUniqueInput
    update: XOR<partenaire_userUpdateWithoutUserInput, partenaire_userUncheckedUpdateWithoutUserInput>
    create: XOR<partenaire_userCreateWithoutUserInput, partenaire_userUncheckedCreateWithoutUserInput>
  }

  export type partenaire_userUpdateWithWhereUniqueWithoutUserInput = {
    where: partenaire_userWhereUniqueInput
    data: XOR<partenaire_userUpdateWithoutUserInput, partenaire_userUncheckedUpdateWithoutUserInput>
  }

  export type partenaire_userUpdateManyWithWhereWithoutUserInput = {
    where: partenaire_userScalarWhereInput
    data: XOR<partenaire_userUpdateManyMutationInput, partenaire_userUncheckedUpdateManyWithoutUserInput>
  }

  export type mediaUpsertWithWhereUniqueWithoutUserInput = {
    where: mediaWhereUniqueInput
    update: XOR<mediaUpdateWithoutUserInput, mediaUncheckedUpdateWithoutUserInput>
    create: XOR<mediaCreateWithoutUserInput, mediaUncheckedCreateWithoutUserInput>
  }

  export type mediaUpdateWithWhereUniqueWithoutUserInput = {
    where: mediaWhereUniqueInput
    data: XOR<mediaUpdateWithoutUserInput, mediaUncheckedUpdateWithoutUserInput>
  }

  export type mediaUpdateManyWithWhereWithoutUserInput = {
    where: mediaScalarWhereInput
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type mediaScalarWhereInput = {
    AND?: Enumerable<mediaScalarWhereInput>
    OR?: Enumerable<mediaScalarWhereInput>
    NOT?: Enumerable<mediaScalarWhereInput>
    id?: IntFilter | number
    image?: StringFilter | string
    id_event?: IntFilter | number
    id_user?: IntFilter | number
    id_type?: IntFilter | number
  }

  export type evenementsCreateWithoutLieuInput = {
    nom: string
    description: string
    categorie?: CategoriesCreateNestedOneWithoutEventsInput
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireCreateNestedManyWithoutEventInput
    media?: mediaCreateNestedManyWithoutEventInput
  }

  export type evenementsUncheckedCreateWithoutLieuInput = {
    id?: number
    nom: string
    description: string
    id_categorie: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireUncheckedCreateNestedManyWithoutEventInput
    media?: mediaUncheckedCreateNestedManyWithoutEventInput
  }

  export type evenementsCreateOrConnectWithoutLieuInput = {
    where: evenementsWhereUniqueInput
    create: XOR<evenementsCreateWithoutLieuInput, evenementsUncheckedCreateWithoutLieuInput>
  }

  export type evenementsCreateManyLieuInputEnvelope = {
    data: Enumerable<evenementsCreateManyLieuInput>
    skipDuplicates?: boolean
  }

  export type evenementsUpsertWithWhereUniqueWithoutLieuInput = {
    where: evenementsWhereUniqueInput
    update: XOR<evenementsUpdateWithoutLieuInput, evenementsUncheckedUpdateWithoutLieuInput>
    create: XOR<evenementsCreateWithoutLieuInput, evenementsUncheckedCreateWithoutLieuInput>
  }

  export type evenementsUpdateWithWhereUniqueWithoutLieuInput = {
    where: evenementsWhereUniqueInput
    data: XOR<evenementsUpdateWithoutLieuInput, evenementsUncheckedUpdateWithoutLieuInput>
  }

  export type evenementsUpdateManyWithWhereWithoutLieuInput = {
    where: evenementsScalarWhereInput
    data: XOR<evenementsUpdateManyMutationInput, evenementsUncheckedUpdateManyWithoutEventsInput>
  }

  export type evenementsScalarWhereInput = {
    AND?: Enumerable<evenementsScalarWhereInput>
    OR?: Enumerable<evenementsScalarWhereInput>
    NOT?: Enumerable<evenementsScalarWhereInput>
    id?: IntFilter | number
    nom?: StringFilter | string
    description?: StringFilter | string
    id_lieu?: IntFilter | number
    id_categorie?: IntFilter | number
    dateDebut?: DateTimeFilter | Date | string
    dateFin?: DateTimeFilter | Date | string
    dateLimit?: DateTimeFilter | Date | string
    nbPlace?: IntFilter | number
    prix?: IntFilter | number
    isPublic?: BoolFilter | boolean
  }

  export type evenementsCreateWithoutCategorieInput = {
    nom: string
    description: string
    lieu?: LieuCreateNestedOneWithoutEventsInput
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireCreateNestedManyWithoutEventInput
    media?: mediaCreateNestedManyWithoutEventInput
  }

  export type evenementsUncheckedCreateWithoutCategorieInput = {
    id?: number
    nom: string
    description: string
    id_lieu: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireUncheckedCreateNestedManyWithoutEventInput
    media?: mediaUncheckedCreateNestedManyWithoutEventInput
  }

  export type evenementsCreateOrConnectWithoutCategorieInput = {
    where: evenementsWhereUniqueInput
    create: XOR<evenementsCreateWithoutCategorieInput, evenementsUncheckedCreateWithoutCategorieInput>
  }

  export type evenementsCreateManyCategorieInputEnvelope = {
    data: Enumerable<evenementsCreateManyCategorieInput>
    skipDuplicates?: boolean
  }

  export type evenementsUpsertWithWhereUniqueWithoutCategorieInput = {
    where: evenementsWhereUniqueInput
    update: XOR<evenementsUpdateWithoutCategorieInput, evenementsUncheckedUpdateWithoutCategorieInput>
    create: XOR<evenementsCreateWithoutCategorieInput, evenementsUncheckedCreateWithoutCategorieInput>
  }

  export type evenementsUpdateWithWhereUniqueWithoutCategorieInput = {
    where: evenementsWhereUniqueInput
    data: XOR<evenementsUpdateWithoutCategorieInput, evenementsUncheckedUpdateWithoutCategorieInput>
  }

  export type evenementsUpdateManyWithWhereWithoutCategorieInput = {
    where: evenementsScalarWhereInput
    data: XOR<evenementsUpdateManyMutationInput, evenementsUncheckedUpdateManyWithoutEventsInput>
  }

  export type LieuCreateWithoutEventsInput = {
    nomLieu: string
    adresse: string
  }

  export type LieuUncheckedCreateWithoutEventsInput = {
    id?: number
    nomLieu: string
    adresse: string
  }

  export type LieuCreateOrConnectWithoutEventsInput = {
    where: LieuWhereUniqueInput
    create: XOR<LieuCreateWithoutEventsInput, LieuUncheckedCreateWithoutEventsInput>
  }

  export type CategoriesCreateWithoutEventsInput = {
    categorie: string
  }

  export type CategoriesUncheckedCreateWithoutEventsInput = {
    id?: number
    categorie: string
  }

  export type CategoriesCreateOrConnectWithoutEventsInput = {
    where: CategoriesWhereUniqueInput
    create: XOR<CategoriesCreateWithoutEventsInput, CategoriesUncheckedCreateWithoutEventsInput>
  }

  export type event_partenaireCreateWithoutEventInput = {
    partenaire?: UsersCreateNestedOneWithoutPartenaireInput
  }

  export type event_partenaireUncheckedCreateWithoutEventInput = {
    id?: number
    id_partenaire: number
  }

  export type event_partenaireCreateOrConnectWithoutEventInput = {
    where: event_partenaireWhereUniqueInput
    create: XOR<event_partenaireCreateWithoutEventInput, event_partenaireUncheckedCreateWithoutEventInput>
  }

  export type event_partenaireCreateManyEventInputEnvelope = {
    data: Enumerable<event_partenaireCreateManyEventInput>
    skipDuplicates?: boolean
  }

  export type mediaCreateWithoutEventInput = {
    image: string
    user?: UsersCreateNestedOneWithoutMediaInput
    typeId?: mediatypeCreateNestedOneWithoutMediaInput
  }

  export type mediaUncheckedCreateWithoutEventInput = {
    id?: number
    image: string
    id_user: number
    id_type: number
  }

  export type mediaCreateOrConnectWithoutEventInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutEventInput, mediaUncheckedCreateWithoutEventInput>
  }

  export type mediaCreateManyEventInputEnvelope = {
    data: Enumerable<mediaCreateManyEventInput>
    skipDuplicates?: boolean
  }

  export type LieuUpsertWithoutEventsInput = {
    update: XOR<LieuUpdateWithoutEventsInput, LieuUncheckedUpdateWithoutEventsInput>
    create: XOR<LieuCreateWithoutEventsInput, LieuUncheckedCreateWithoutEventsInput>
  }

  export type LieuUpdateWithoutEventsInput = {
    nomLieu?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
  }

  export type LieuUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomLieu?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUpsertWithoutEventsInput = {
    update: XOR<CategoriesUpdateWithoutEventsInput, CategoriesUncheckedUpdateWithoutEventsInput>
    create: XOR<CategoriesCreateWithoutEventsInput, CategoriesUncheckedCreateWithoutEventsInput>
  }

  export type CategoriesUpdateWithoutEventsInput = {
    categorie?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorie?: StringFieldUpdateOperationsInput | string
  }

  export type event_partenaireUpsertWithWhereUniqueWithoutEventInput = {
    where: event_partenaireWhereUniqueInput
    update: XOR<event_partenaireUpdateWithoutEventInput, event_partenaireUncheckedUpdateWithoutEventInput>
    create: XOR<event_partenaireCreateWithoutEventInput, event_partenaireUncheckedCreateWithoutEventInput>
  }

  export type event_partenaireUpdateWithWhereUniqueWithoutEventInput = {
    where: event_partenaireWhereUniqueInput
    data: XOR<event_partenaireUpdateWithoutEventInput, event_partenaireUncheckedUpdateWithoutEventInput>
  }

  export type event_partenaireUpdateManyWithWhereWithoutEventInput = {
    where: event_partenaireScalarWhereInput
    data: XOR<event_partenaireUpdateManyMutationInput, event_partenaireUncheckedUpdateManyWithoutEventInput>
  }

  export type mediaUpsertWithWhereUniqueWithoutEventInput = {
    where: mediaWhereUniqueInput
    update: XOR<mediaUpdateWithoutEventInput, mediaUncheckedUpdateWithoutEventInput>
    create: XOR<mediaCreateWithoutEventInput, mediaUncheckedCreateWithoutEventInput>
  }

  export type mediaUpdateWithWhereUniqueWithoutEventInput = {
    where: mediaWhereUniqueInput
    data: XOR<mediaUpdateWithoutEventInput, mediaUncheckedUpdateWithoutEventInput>
  }

  export type mediaUpdateManyWithWhereWithoutEventInput = {
    where: mediaScalarWhereInput
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type evenementsCreateWithoutEventInput = {
    nom: string
    description: string
    lieu?: LieuCreateNestedOneWithoutEventsInput
    categorie?: CategoriesCreateNestedOneWithoutEventsInput
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    media?: mediaCreateNestedManyWithoutEventInput
  }

  export type evenementsUncheckedCreateWithoutEventInput = {
    id?: number
    nom: string
    description: string
    id_lieu: number
    id_categorie: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    media?: mediaUncheckedCreateNestedManyWithoutEventInput
  }

  export type evenementsCreateOrConnectWithoutEventInput = {
    where: evenementsWhereUniqueInput
    create: XOR<evenementsCreateWithoutEventInput, evenementsUncheckedCreateWithoutEventInput>
  }

  export type UsersCreateWithoutPartenaireInput = {
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    role?: RolesCreateNestedOneWithoutUsersInput
    mypartenaire?: partenaire_userCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutPartenaireInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    id_role: number
    mypartenaire?: partenaire_userUncheckedCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutPartenaireInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPartenaireInput, UsersUncheckedCreateWithoutPartenaireInput>
  }

  export type evenementsUpsertWithoutEventInput = {
    update: XOR<evenementsUpdateWithoutEventInput, evenementsUncheckedUpdateWithoutEventInput>
    create: XOR<evenementsCreateWithoutEventInput, evenementsUncheckedCreateWithoutEventInput>
  }

  export type evenementsUpdateWithoutEventInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lieu?: LieuUpdateOneWithoutEventsInput
    categorie?: CategoriesUpdateOneWithoutEventsInput
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    media?: mediaUpdateManyWithoutEventInput
  }

  export type evenementsUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    id_lieu?: IntFieldUpdateOperationsInput | number
    id_categorie?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    media?: mediaUncheckedUpdateManyWithoutEventInput
  }

  export type UsersUpsertWithoutPartenaireInput = {
    update: XOR<UsersUpdateWithoutPartenaireInput, UsersUncheckedUpdateWithoutPartenaireInput>
    create: XOR<UsersCreateWithoutPartenaireInput, UsersUncheckedCreateWithoutPartenaireInput>
  }

  export type UsersUpdateWithoutPartenaireInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: RolesUpdateOneWithoutUsersInput
    mypartenaire?: partenaire_userUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
  }

  export type UsersUncheckedUpdateWithoutPartenaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    id_role?: IntFieldUpdateOperationsInput | number
    mypartenaire?: partenaire_userUncheckedUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
  }

  export type UsersCreateWithoutMypartenaireInput = {
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    role?: RolesCreateNestedOneWithoutUsersInput
    partenaire?: event_partenaireCreateNestedManyWithoutPartenaireInput
    user?: partenaire_userCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutMypartenaireInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    id_role: number
    partenaire?: event_partenaireUncheckedCreateNestedManyWithoutPartenaireInput
    user?: partenaire_userUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutMypartenaireInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMypartenaireInput, UsersUncheckedCreateWithoutMypartenaireInput>
  }

  export type UsersCreateWithoutUserInput = {
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    role?: RolesCreateNestedOneWithoutUsersInput
    partenaire?: event_partenaireCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userCreateNestedManyWithoutMypartenaireInput
    media?: mediaCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutUserInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    id_role: number
    partenaire?: event_partenaireUncheckedCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedCreateNestedManyWithoutMypartenaireInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutUserInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserInput, UsersUncheckedCreateWithoutUserInput>
  }

  export type UsersUpsertWithoutMypartenaireInput = {
    update: XOR<UsersUpdateWithoutMypartenaireInput, UsersUncheckedUpdateWithoutMypartenaireInput>
    create: XOR<UsersCreateWithoutMypartenaireInput, UsersUncheckedCreateWithoutMypartenaireInput>
  }

  export type UsersUpdateWithoutMypartenaireInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: RolesUpdateOneWithoutUsersInput
    partenaire?: event_partenaireUpdateManyWithoutPartenaireInput
    user?: partenaire_userUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
  }

  export type UsersUncheckedUpdateWithoutMypartenaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    id_role?: IntFieldUpdateOperationsInput | number
    partenaire?: event_partenaireUncheckedUpdateManyWithoutPartenaireInput
    user?: partenaire_userUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
  }

  export type UsersUpsertWithoutUserInput = {
    update: XOR<UsersUpdateWithoutUserInput, UsersUncheckedUpdateWithoutUserInput>
    create: XOR<UsersCreateWithoutUserInput, UsersUncheckedCreateWithoutUserInput>
  }

  export type UsersUpdateWithoutUserInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: RolesUpdateOneWithoutUsersInput
    partenaire?: event_partenaireUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUpdateManyWithoutMypartenaireInput
    media?: mediaUpdateManyWithoutUserInput
  }

  export type UsersUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    id_role?: IntFieldUpdateOperationsInput | number
    partenaire?: event_partenaireUncheckedUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedUpdateManyWithoutMypartenaireInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
  }

  export type mediaCreateWithoutTypeIdInput = {
    image: string
    user?: UsersCreateNestedOneWithoutMediaInput
    event?: evenementsCreateNestedOneWithoutMediaInput
  }

  export type mediaUncheckedCreateWithoutTypeIdInput = {
    id?: number
    image: string
    id_event: number
    id_user: number
  }

  export type mediaCreateOrConnectWithoutTypeIdInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutTypeIdInput, mediaUncheckedCreateWithoutTypeIdInput>
  }

  export type mediaCreateManyTypeIdInputEnvelope = {
    data: Enumerable<mediaCreateManyTypeIdInput>
    skipDuplicates?: boolean
  }

  export type mediaUpsertWithWhereUniqueWithoutTypeIdInput = {
    where: mediaWhereUniqueInput
    update: XOR<mediaUpdateWithoutTypeIdInput, mediaUncheckedUpdateWithoutTypeIdInput>
    create: XOR<mediaCreateWithoutTypeIdInput, mediaUncheckedCreateWithoutTypeIdInput>
  }

  export type mediaUpdateWithWhereUniqueWithoutTypeIdInput = {
    where: mediaWhereUniqueInput
    data: XOR<mediaUpdateWithoutTypeIdInput, mediaUncheckedUpdateWithoutTypeIdInput>
  }

  export type mediaUpdateManyWithWhereWithoutTypeIdInput = {
    where: mediaScalarWhereInput
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type UsersCreateWithoutMediaInput = {
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    role?: RolesCreateNestedOneWithoutUsersInput
    partenaire?: event_partenaireCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutMediaInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
    id_role: number
    partenaire?: event_partenaireUncheckedCreateNestedManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedCreateNestedManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutMediaInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput>
  }

  export type evenementsCreateWithoutMediaInput = {
    nom: string
    description: string
    lieu?: LieuCreateNestedOneWithoutEventsInput
    categorie?: CategoriesCreateNestedOneWithoutEventsInput
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireCreateNestedManyWithoutEventInput
  }

  export type evenementsUncheckedCreateWithoutMediaInput = {
    id?: number
    nom: string
    description: string
    id_lieu: number
    id_categorie: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
    event?: event_partenaireUncheckedCreateNestedManyWithoutEventInput
  }

  export type evenementsCreateOrConnectWithoutMediaInput = {
    where: evenementsWhereUniqueInput
    create: XOR<evenementsCreateWithoutMediaInput, evenementsUncheckedCreateWithoutMediaInput>
  }

  export type mediatypeCreateWithoutMediaInput = {
    libelle: string
  }

  export type mediatypeUncheckedCreateWithoutMediaInput = {
    id?: number
    libelle: string
  }

  export type mediatypeCreateOrConnectWithoutMediaInput = {
    where: mediatypeWhereUniqueInput
    create: XOR<mediatypeCreateWithoutMediaInput, mediatypeUncheckedCreateWithoutMediaInput>
  }

  export type UsersUpsertWithoutMediaInput = {
    update: XOR<UsersUpdateWithoutMediaInput, UsersUncheckedUpdateWithoutMediaInput>
    create: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput>
  }

  export type UsersUpdateWithoutMediaInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: RolesUpdateOneWithoutUsersInput
    partenaire?: event_partenaireUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUpdateManyWithoutUserInput
  }

  export type UsersUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    id_role?: IntFieldUpdateOperationsInput | number
    partenaire?: event_partenaireUncheckedUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedUpdateManyWithoutUserInput
  }

  export type evenementsUpsertWithoutMediaInput = {
    update: XOR<evenementsUpdateWithoutMediaInput, evenementsUncheckedUpdateWithoutMediaInput>
    create: XOR<evenementsCreateWithoutMediaInput, evenementsUncheckedCreateWithoutMediaInput>
  }

  export type evenementsUpdateWithoutMediaInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lieu?: LieuUpdateOneWithoutEventsInput
    categorie?: CategoriesUpdateOneWithoutEventsInput
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUpdateManyWithoutEventInput
  }

  export type evenementsUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    id_lieu?: IntFieldUpdateOperationsInput | number
    id_categorie?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUncheckedUpdateManyWithoutEventInput
  }

  export type mediatypeUpsertWithoutMediaInput = {
    update: XOR<mediatypeUpdateWithoutMediaInput, mediatypeUncheckedUpdateWithoutMediaInput>
    create: XOR<mediatypeCreateWithoutMediaInput, mediatypeUncheckedCreateWithoutMediaInput>
  }

  export type mediatypeUpdateWithoutMediaInput = {
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type mediatypeUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateManyRoleInput = {
    id?: number
    nom: string
    prenom: string
    login: string
    password: string
    adresse: string
    email: string
    token: string
  }

  export type UsersUpdateWithoutRoleInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    partenaire?: event_partenaireUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
  }

  export type UsersUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    partenaire?: event_partenaireUncheckedUpdateManyWithoutPartenaireInput
    mypartenaire?: partenaire_userUncheckedUpdateManyWithoutMypartenaireInput
    user?: partenaire_userUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
  }

  export type UsersUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type event_partenaireCreateManyPartenaireInput = {
    id?: number
    id_event: number
  }

  export type partenaire_userCreateManyMypartenaireInput = {
    id?: number
    id_user: number
  }

  export type partenaire_userCreateManyUserInput = {
    id?: number
    id_partenaire: number
  }

  export type mediaCreateManyUserInput = {
    id?: number
    image: string
    id_event: number
    id_type: number
  }

  export type event_partenaireUpdateWithoutPartenaireInput = {
    event?: evenementsUpdateOneWithoutEventInput
  }

  export type event_partenaireUncheckedUpdateWithoutPartenaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_event?: IntFieldUpdateOperationsInput | number
  }

  export type partenaire_userUpdateWithoutMypartenaireInput = {
    user?: UsersUpdateOneWithoutUserInput
  }

  export type partenaire_userUncheckedUpdateWithoutMypartenaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type partenaire_userUpdateWithoutUserInput = {
    mypartenaire?: UsersUpdateOneWithoutMypartenaireInput
  }

  export type partenaire_userUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_partenaire?: IntFieldUpdateOperationsInput | number
  }

  export type mediaUpdateWithoutUserInput = {
    image?: StringFieldUpdateOperationsInput | string
    event?: evenementsUpdateOneWithoutMediaInput
    typeId?: mediatypeUpdateOneWithoutMediaInput
  }

  export type mediaUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    id_event?: IntFieldUpdateOperationsInput | number
    id_type?: IntFieldUpdateOperationsInput | number
  }

  export type mediaUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    id_event?: IntFieldUpdateOperationsInput | number
    id_type?: IntFieldUpdateOperationsInput | number
  }

  export type evenementsCreateManyLieuInput = {
    id?: number
    nom: string
    description: string
    id_categorie: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
  }

  export type evenementsUpdateWithoutLieuInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categorie?: CategoriesUpdateOneWithoutEventsInput
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUpdateManyWithoutEventInput
    media?: mediaUpdateManyWithoutEventInput
  }

  export type evenementsUncheckedUpdateWithoutLieuInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    id_categorie?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUncheckedUpdateManyWithoutEventInput
    media?: mediaUncheckedUpdateManyWithoutEventInput
  }

  export type evenementsUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    id_categorie?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type evenementsCreateManyCategorieInput = {
    id?: number
    nom: string
    description: string
    id_lieu: number
    dateDebut: Date | string
    dateFin: Date | string
    dateLimit: Date | string
    nbPlace: number
    prix: number
    isPublic: boolean
  }

  export type evenementsUpdateWithoutCategorieInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lieu?: LieuUpdateOneWithoutEventsInput
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUpdateManyWithoutEventInput
    media?: mediaUpdateManyWithoutEventInput
  }

  export type evenementsUncheckedUpdateWithoutCategorieInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    id_lieu?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLimit?: DateTimeFieldUpdateOperationsInput | Date | string
    nbPlace?: IntFieldUpdateOperationsInput | number
    prix?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    event?: event_partenaireUncheckedUpdateManyWithoutEventInput
    media?: mediaUncheckedUpdateManyWithoutEventInput
  }

  export type event_partenaireCreateManyEventInput = {
    id?: number
    id_partenaire: number
  }

  export type mediaCreateManyEventInput = {
    id?: number
    image: string
    id_user: number
    id_type: number
  }

  export type event_partenaireUpdateWithoutEventInput = {
    partenaire?: UsersUpdateOneWithoutPartenaireInput
  }

  export type event_partenaireUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_partenaire?: IntFieldUpdateOperationsInput | number
  }

  export type mediaUpdateWithoutEventInput = {
    image?: StringFieldUpdateOperationsInput | string
    user?: UsersUpdateOneWithoutMediaInput
    typeId?: mediatypeUpdateOneWithoutMediaInput
  }

  export type mediaUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    id_user?: IntFieldUpdateOperationsInput | number
    id_type?: IntFieldUpdateOperationsInput | number
  }

  export type mediaCreateManyTypeIdInput = {
    id?: number
    image: string
    id_event: number
    id_user: number
  }

  export type mediaUpdateWithoutTypeIdInput = {
    image?: StringFieldUpdateOperationsInput | string
    user?: UsersUpdateOneWithoutMediaInput
    event?: evenementsUpdateOneWithoutMediaInput
  }

  export type mediaUncheckedUpdateWithoutTypeIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    id_event?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}